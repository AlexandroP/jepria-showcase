<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="ru">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Overview (JepRiaShowcase JavaDoc)</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (JepRiaShowcase JavaDoc)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">JepRiaShowcase API Reference</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">Модуль предназначен для демонстрации возможностей, отладки, автоматизированного тестирования функционала JepRia.</div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/client/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/server/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/server/dao/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/server/service/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/shared/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/shared/field/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/shared/record/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/shared/service/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/allshopgoods/shared/text/package-summary.html">com.technology.jep.jepriashowcase.allshopgoods.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/client/package-summary.html">com.technology.jep.jepriashowcase.arsenic.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/client/images/package-summary.html">com.technology.jep.jepriashowcase.arsenic.client.images</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.arsenic.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.arsenic.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/server/package-summary.html">com.technology.jep.jepriashowcase.arsenic.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/server/dao/package-summary.html">com.technology.jep.jepriashowcase.arsenic.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/server/service/package-summary.html">com.technology.jep.jepriashowcase.arsenic.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/shared/package-summary.html">com.technology.jep.jepriashowcase.arsenic.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/shared/field/package-summary.html">com.technology.jep.jepriashowcase.arsenic.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/shared/record/package-summary.html">com.technology.jep.jepriashowcase.arsenic.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/shared/service/package-summary.html">com.technology.jep.jepriashowcase.arsenic.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/arsenic/shared/text/package-summary.html">com.technology.jep.jepriashowcase.arsenic.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/client/package-summary.html">com.technology.jep.jepriashowcase.custom.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/client/ui/package-summary.html">com.technology.jep.jepriashowcase.custom.client.ui</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/client/ui/auto/package-summary.html">com.technology.jep.jepriashowcase.custom.client.ui.auto</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/client/ui/plain/package-summary.html">com.technology.jep.jepriashowcase.custom.client.ui.plain</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/server/package-summary.html">com.technology.jep.jepriashowcase.custom.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/server/dao/package-summary.html">com.technology.jep.jepriashowcase.custom.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/server/service/package-summary.html">com.technology.jep.jepriashowcase.custom.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/package-summary.html">com.technology.jep.jepriashowcase.custom.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/field/package-summary.html">com.technology.jep.jepriashowcase.custom.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/record/package-summary.html">com.technology.jep.jepriashowcase.custom.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/service/package-summary.html">com.technology.jep.jepriashowcase.custom.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/text/package-summary.html">com.technology.jep.jepriashowcase.custom.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/custom/shared/ui/package-summary.html">com.technology.jep.jepriashowcase.custom.shared.ui</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/client/package-summary.html">com.technology.jep.jepriashowcase.feature.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.feature.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.feature.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/client/ui/form/list/event/package-summary.html">com.technology.jep.jepriashowcase.feature.client.ui.form.list.event</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/server/package-summary.html">com.technology.jep.jepriashowcase.feature.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/server/dao/package-summary.html">com.technology.jep.jepriashowcase.feature.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/server/service/package-summary.html">com.technology.jep.jepriashowcase.feature.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/shared/package-summary.html">com.technology.jep.jepriashowcase.feature.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/shared/field/package-summary.html">com.technology.jep.jepriashowcase.feature.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/shared/record/package-summary.html">com.technology.jep.jepriashowcase.feature.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/shared/service/package-summary.html">com.technology.jep.jepriashowcase.feature.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/feature/shared/text/package-summary.html">com.technology.jep.jepriashowcase.feature.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/client/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/client/ui/toolbar/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.client.ui.toolbar</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/server/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/server/dao/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/server/service/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/shared/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/shared/field/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/shared/record/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/shared/service/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureoperator/shared/text/package-summary.html">com.technology.jep.jepriashowcase.featureoperator.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/client/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/client/ui/toolbar/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.client.ui.toolbar</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/server/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/server/dao/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/server/service/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/shared/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/shared/field/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/shared/record/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/shared/service/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/featureprocess/shared/text/package-summary.html">com.technology.jep.jepriashowcase.featureprocess.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/client/package-summary.html">com.technology.jep.jepriashowcase.goods.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.goods.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.goods.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/server/package-summary.html">com.technology.jep.jepriashowcase.goods.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/server/dao/package-summary.html">com.technology.jep.jepriashowcase.goods.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/server/service/package-summary.html">com.technology.jep.jepriashowcase.goods.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/shared/package-summary.html">com.technology.jep.jepriashowcase.goods.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/shared/field/package-summary.html">com.technology.jep.jepriashowcase.goods.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/shared/record/package-summary.html">com.technology.jep.jepriashowcase.goods.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/shared/service/package-summary.html">com.technology.jep.jepriashowcase.goods.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/goods/shared/text/package-summary.html">com.technology.jep.jepriashowcase.goods.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/client/package-summary.html">com.technology.jep.jepriashowcase.main.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/client/entrance/package-summary.html">com.technology.jep.jepriashowcase.main.client.entrance</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/client/style/package-summary.html">com.technology.jep.jepriashowcase.main.client.style</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/client/ui/main/package-summary.html">com.technology.jep.jepriashowcase.main.client.ui.main</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/shared/package-summary.html">com.technology.jep.jepriashowcase.main.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/shared/field/package-summary.html">com.technology.jep.jepriashowcase.main.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/main/shared/text/package-summary.html">com.technology.jep.jepriashowcase.main.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/client/package-summary.html">com.technology.jep.jepriashowcase.request.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.request.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.request.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/server/package-summary.html">com.technology.jep.jepriashowcase.request.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/server/dao/package-summary.html">com.technology.jep.jepriashowcase.request.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/server/service/package-summary.html">com.technology.jep.jepriashowcase.request.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/shared/package-summary.html">com.technology.jep.jepriashowcase.request.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/shared/field/package-summary.html">com.technology.jep.jepriashowcase.request.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/shared/record/package-summary.html">com.technology.jep.jepriashowcase.request.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/shared/service/package-summary.html">com.technology.jep.jepriashowcase.request.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/request/shared/text/package-summary.html">com.technology.jep.jepriashowcase.request.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/client/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/server/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/server/dao/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/server/service/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/shared/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/shared/field/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/shared/record/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/shared/service/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/requestprocess/shared/text/package-summary.html">com.technology.jep.jepriashowcase.requestprocess.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/client/package-summary.html">com.technology.jep.jepriashowcase.search.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/client/shop/package-summary.html">com.technology.jep.jepriashowcase.search.client.shop</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/client/ui/plain/package-summary.html">com.technology.jep.jepriashowcase.search.client.ui.plain</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/client/widget/list/package-summary.html">com.technology.jep.jepriashowcase.search.client.widget.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/client/widget/toolbar/package-summary.html">com.technology.jep.jepriashowcase.search.client.widget.toolbar</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/server/package-summary.html">com.technology.jep.jepriashowcase.search.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/server/dao/package-summary.html">com.technology.jep.jepriashowcase.search.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/server/service/package-summary.html">com.technology.jep.jepriashowcase.search.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/shared/package-summary.html">com.technology.jep.jepriashowcase.search.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/shared/field/package-summary.html">com.technology.jep.jepriashowcase.search.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/shared/record/package-summary.html">com.technology.jep.jepriashowcase.search.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/shared/service/package-summary.html">com.technology.jep.jepriashowcase.search.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/search/shared/text/package-summary.html">com.technology.jep.jepriashowcase.search.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/client/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/server/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/server/dao/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/server/service/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/shared/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/shared/field/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/shared/record/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/shared/service/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/shopgoods/shared/text/package-summary.html">com.technology.jep.jepriashowcase.shopgoods.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/client/package-summary.html">com.technology.jep.jepriashowcase.simple.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/client/ui/plain/package-summary.html">com.technology.jep.jepriashowcase.simple.client.ui.plain</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/shared/package-summary.html">com.technology.jep.jepriashowcase.simple.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/shared/field/package-summary.html">com.technology.jep.jepriashowcase.simple.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/shared/record/package-summary.html">com.technology.jep.jepriashowcase.simple.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/simple/shared/text/package-summary.html">com.technology.jep.jepriashowcase.simple.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/client/package-summary.html">com.technology.jep.jepriashowcase.supplier.client</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/client/ui/form/detail/package-summary.html">com.technology.jep.jepriashowcase.supplier.client.ui.form.detail</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/client/ui/form/list/package-summary.html">com.technology.jep.jepriashowcase.supplier.client.ui.form.list</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/client/ui/wizard/package-summary.html">com.technology.jep.jepriashowcase.supplier.client.ui.wizard</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/server/package-summary.html">com.technology.jep.jepriashowcase.supplier.server</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/server/dao/package-summary.html">com.technology.jep.jepriashowcase.supplier.server.dao</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/server/service/package-summary.html">com.technology.jep.jepriashowcase.supplier.server.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/shared/package-summary.html">com.technology.jep.jepriashowcase.supplier.shared</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/shared/field/package-summary.html">com.technology.jep.jepriashowcase.supplier.shared.field</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/shared/record/package-summary.html">com.technology.jep.jepriashowcase.supplier.shared.record</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/shared/service/package-summary.html">com.technology.jep.jepriashowcase.supplier.shared.service</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/technology/jep/jepriashowcase/supplier/shared/text/package-summary.html">com.technology.jep.jepriashowcase.supplier.shared.text</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block">Модуль предназначен для демонстрации возможностей, отладки, автоматизированного тестирования функционала JepRia.
<br>
<h2>Содержание</h2>
<ul>
    <li><a href="#about">Описание</a></li>
    <li><a href="#cmd">Решение проблемы некорректного отображения русских символов при запуске команд Ant.</a></li>
    <li><a href="#build">Сборка приложения для Production</a></li>
    <li><a href="#ieProblem">Обеспечение совместимости под различные браузеры</a></li>
    <li><a href="#standardSolutions">Типовые решения</a></li>
    <li><a href="#refactoringNeeded">Косвенные признаки необходимости рефакторинга</a></li>
    <li><a href="#autoTestConcept">Автоматизированное тестирование</a>
        <ul>
            <li><a href="#autoTestGeneral">Общие положения</a></li>
            <li><a href="#autoTestTargets">Список ant-целей для запуска тестов</a></li>
            <li><a href="#autoTestGwtTestCase">Особенности использования GWTTestCase</a></li>
        </ul> </li>
    <li><a href="#cssAgreement">Соглашение по использованию стилей css</a></li>
    <li><a href="#buildScenarioUpdate">Корректное обновление сценария сборки</a></li>
    <li><a href="#binRepoPreparation">Подготовка бинарного репозитория</a></li>
    <li><a href="#deploy">Установка</a></li>
    <li><a href="#testCases">Тестовые сценарии</a></li>
    <li><a href="#error">Ошибки</a></li>
    <li><a href="#todo">Доработки</a></li>
    <li><a href="#releaseNotes">Замечания к версиям</a></li>
</ul>
<h3><a name="about">Описание</a></h3> Основная идея приложения - продемонстрировать возможности платформы JepRia, предоставить работающие (с актуальными исходными кодами)
<a href="#standardSolutions">Типовые решения</a> на уровне приложения.
<br> Модуль предполагает создание
<a href="#autoTestConcept">Автоматизированных тестов</a> возможностей JepRia и
<a href="#standardSolutions">Типовых решений</a>, таким образом предполагается поддерживать качество версий JepRia и обеспечивать оптимальную совместимость с уже реализованным функционалом.
<h3><a name="cmd">Решение проблемы некорректного отображения русских символов при запуске команд Ant.</a></h3> При запуске команд Ant в командную строку могут выводится русские символы (например, содержащихся в исключениях), для корректного отображения необходимо выполнить следующую команду:
<br>
<br>
<code>chcp 1251</code>
<h3><a name="build">Сборка приложения для Production</a></h3> При сборке приложений JepRia для Production необходимо выполнить следующие действия:
<br>
<ul>
    <li>отключить клиентский лог<br> Отключение клиентского лога выполняется в файле <i>&lt;Application Name&gt;.gwt.xml</i> комментированием соответствующих строк (см. выделенные строки): <pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;module rename-to="Application Name"&gt;
…
<b>
&lt;!-- &lt;inherits name="com.allen_sauer.gwt.log.gwt-log-RemoteLogger" /&gt; --&gt;
&lt;!-- &lt;extend-property name="log_level" values="TRACE" /&gt; --&gt;
&lt;!-- &lt;set-property name="log_level" value="TRACE" /&gt; --&gt;
&lt;!-- &lt;set-property name="log_DivLogger" value="ENABLED"/&gt; --&gt;
</b>
…
&lt;/module&gt;
</pre> </li>
    <li>установить для уровеня серверного логирования значение <b>INFO</b><br> Установка уровня серверного логирования выполняется в файле <i>log4j.properties</i> (см. выделенные строки): <pre>
#
...
log4j.logger.com.technology.&lt;project name&gt;.&lt;application name&gt;=<b>INFO</b>, FILE, gwt-log
...
log4j.logger.gwt-log=<b>INFO</b>, gwt-log
...
log4j.logger.com.technology.jep.jepria.shared=<b>INFO</b>, FILE, gwt-log
...
log4j.logger.com.technology.jep.jepria.server=<b>INFO</b>, FILE, gwt-log
log4j.logger.com.technology.jep.jepcommon=<b>INFO</b>, FILE, gwt-log
...
</pre> </li>
    <li>удалить установку symbolMaps parameter для сервлета Gwt-Log посредством комментирования соответствующих строк файла <i>web.xml</i> (см. выделение): <pre>
...
    <b>&lt;!-- &lt;init-param&gt; --&gt;</b>
      &lt;!-- This value assumes a GWT compile with '-deploy war/WEB-INF/deploy/' --&gt;
      <b>&lt;!-- &lt;param-name&gt;symbolMaps&lt;/param-name&gt; --&gt;</b>
...
      <b>&lt;!-- &lt;param-value&gt;../j2ee/home/applications/&lt;application name&gt;/&lt;application name&gt;/&lt;Application Name&gt;/symbolMaps/&lt;/param-value&gt; --&gt;</b>
    <b>&lt;!-- &lt;/init-param&gt; --&gt;</b>
...
</pre> </li>
    <li>убрать генерирование symbolMaps для сервлета Gwt-Log при GWT-компиляции<br> Отключение генерации symbolMaps выполняется удалением параметра <i>-deploy</i> из параметров вызова компилятора - посредством комментирования соответствующих строк файла <i>build.xml</i> (см. выделение): <pre>
&lt;project name="Jep Module Building" default="build-and-deploy"&gt;
...
  &lt;target name="all-gwt-compile" depends="all-text-encode, java-compile"&gt;
...
    &lt;java failonerror="true" fork="true" maxmemory="256m" classname="com.google.gwt.dev.Compiler"&gt;
      &lt;classpath&gt;
        &lt;pathelement location="src/java" /&gt;
        &lt;pathelement location="build" /&gt;
        &lt;path refid="libs" /&gt;
      &lt;/classpath&gt;
      &lt;arg value="-war" /&gt;
      &lt;arg value="build-gwt" /&gt;
      &lt;arg value="-style" /&gt;
      &lt;arg value="obfuscated" /&gt;
      &lt;!-- &lt;arg value="-draftCompile"/&gt; --&gt;
      <b>&lt;!-- &lt;arg value="-deploy" /&gt; --&gt;</b>
      <b>&lt;!-- &lt;arg value="build-gwt" /&gt; --&gt;</b>
      &lt;!-- &lt;arg value="-compileReport"/&gt; --&gt;
      &lt;arg value="com.technology.${PROJECT_NAME_IN_PACKAGE}.${MODULE_NAME_IN_PACKAGE}.main.${MODULE_NAME}" /&gt;
    &lt;/java&gt;
...
  &lt;/target&gt;
...
&lt;/project&gt;
</pre> </li>
    <li>включить оптимизацию при GWT-компиляции<br> Включение оптимизации GWT-компилятора выполняется удалением параметра <i>-draftCompile</i> из параметров вызова компилятора - посредством комментирования соответствующей строки файла <i>build.xml</i> (см. выделение): <pre>
&lt;project name="Jep Module Building" default="build-and-deploy"&gt;
...
  &lt;target name="all-gwt-compile" depends="all-text-encode, java-compile"&gt;
...
    &lt;java failonerror="true" fork="true" maxmemory="256m" classname="com.google.gwt.dev.Compiler"&gt;
      &lt;classpath&gt;
        &lt;pathelement location="src/java" /&gt;
        &lt;pathelement location="build" /&gt;
        &lt;path refid="libs" /&gt;
      &lt;/classpath&gt;
      &lt;arg value="-war" /&gt;
      &lt;arg value="build-gwt" /&gt;
      &lt;arg value="-style" /&gt;
      &lt;arg value="obfuscated" /&gt;
      <b>&lt;!-- &lt;arg value="-draftCompile"/&gt; --&gt;</b>
      &lt;!-- &lt;arg value="-deploy" /&gt; --&gt;
      &lt;!-- &lt;arg value="build-gwt" /&gt; --&gt;
      &lt;!-- &lt;arg value="-compileReport"/&gt; --&gt;
      &lt;arg value="com.technology.${PROJECT_NAME_IN_PACKAGE}.${MODULE_NAME_IN_PACKAGE}.main.${MODULE_NAME}" /&gt;
    &lt;/java&gt;
...
  &lt;/target&gt;
...
&lt;/project&gt;
</pre> </li>
    <li>включить генерацию для всех видов браузеров<br> Генерация для всех видов браузеров «включается» в файле <i>&lt;Application Name&gt;.gwt.xml</i>. Для этого необходимо закомментарить теги свойств <i>user.agent, gxt.user.agent, user.agent.os</i>: <pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;module rename-to="Application Name"&gt;
…    
<b>
&lt;!-- &lt;set-property name="user.agent" value="ie9" /&gt; --&gt;
&lt;!-- &lt;set-property name="gxt.user.agent" value="ie9" /&gt; --&gt;
&lt;!-- &lt;set-property name="user.agent.os" value="windows" /&gt; --&gt;
</b>
…
&lt;/module&gt;
</pre> <br> NB. Все возможные комбинации <i>user.agent, gxt.user.agent, user.agent.os</i> можно увидеть при генерации кода под все браузеры, воспользовавшись GWT Compile Report (см. ниже) на странице, где перечислены все Permutations. </li>
    <li>включить генерацию для всех поддерживаемых языков (русский, английский)<br> Генерация русского и английского языков «включается» в файле <i>&lt;Application Name&gt;.gwt.xml</i> следующим образом (см. выделенные строки): <pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;module rename-to="Application Name"&gt;
…    
<b>
  &lt;extend-property name="locale" values="ru" /&gt;
  &lt;extend-property name="locale" values="en" /&gt;
  &lt;set-property-fallback name="locale" value="ru" /&gt;
</b>
…
&lt;/module&gt;
</pre> </li>
    <li>проверить получившийся объем первоначальной загрузки<br> Объем первоначальной загрузки должен быть около 700KB (для приложени <u>любого размера</u>). Все остальное должно находиться в отложенной загрузке (Left Over).<br> Включение генерации GWT Compile Report выполняется добавлением параметра <i>-compileReport</i> в параметрах вызова компилятора - посредством раскомментирования соответствующей строки файла <i>build.xml</i> (см. выделение): <pre>
&lt;project name="Jep Module Building" default="build-and-deploy"&gt;
...
  &lt;target name="all-gwt-compile" depends="all-text-encode, java-compile"&gt;
...
    &lt;java failonerror="true" fork="true" maxmemory="256m" classname="com.google.gwt.dev.Compiler"&gt;
      &lt;classpath&gt;
        &lt;pathelement location="src/java" /&gt;
        &lt;pathelement location="build" /&gt;
        &lt;path refid="libs" /&gt;
      &lt;/classpath&gt;
      &lt;arg value="-war" /&gt;
      &lt;arg value="build-gwt" /&gt;
      &lt;arg value="-style" /&gt;
      &lt;arg value="obfuscated" /&gt;
      &lt;!-- &lt;arg value="-draftCompile"/&gt; --&gt;
      &lt;!-- &lt;arg value="-deploy" /&gt; --&gt;
      &lt;!-- &lt;arg value="build-gwt" /&gt; --&gt;
      <b>&lt;arg value="-compileReport"/&gt;</b>
      &lt;arg value="com.technology.${PROJECT_NAME_IN_PACKAGE}.${MODULE_NAME_IN_PACKAGE}.main.${MODULE_NAME}" /&gt;
    &lt;/java&gt;
...
  &lt;/target&gt;
...
&lt;/project&gt;
</pre> <br> <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCompileReport" target="_blank">Детальная информация о возможностях GWT Compile Report.</a> </li>
</ul>
<h3><a name="ieProblem">Обеспечение совместимости под различные браузеры</a></h3> Размышления / Рекомендации.
<br> К сожалению, использование Gxt (возможно и Gwt) не гарантирует (по опыту) полностью идентичное поведение/функционирование приложений в различных браузерах. Как и прежде, MS Internet Explorer стоит неким ... «особняком» в плане совместимости, и создает основные проблемы для конечных пользователей: то, что надежно работает в других браузерах, не работает (или работает не так) в IE. Поэтому, к сожалению, типична ситуация: разработка ведется в одном из нормальных браузеров (Chrome, Firefox), разработка завершается, приложение отдается пользователям и ... далее начинаются долгий (иногда существенно более долгий, чем сама разработка) процесс отладки/доводки приложения под IE.
<br> Исходя из вышесказанного, возможно, целесообразно придерживаться следующего порядка разработки:
<ol>
    <li>Разработку изначально вести в IE;</li>
    <li>Проверить как приложение встраивается в public-страницу в IE (если приложение предназначено для встраивания в public-страницу);</li>
    <li>Обязательно проверить полученный результат в одном из нормальных браузеров (Chrome, Firefox).</li>
</ol> Использование данного порядка разработки, наверное, будет способствовать снижению общих трудозатрат на разработку (уйдет время на отладку, в пределе, переделку функционала под IE), и, очевидно, будет способствовать снижению негатива, идущего от пользователей IE (пока еще очень многочисленных).
<h3><a name="standardSolutions">Типовые решения</a></h3>
<ul>
    <li><a href="#parameterPassing">Передача параметров между модулями приложения</a></li>
    <li><a href="#parameterPassingBetweenWebApplication">Передача значений между веб-приложениями</a></li>
    <li><a href="#postMessageBetweenWebApplication">Кросс-доменный обмен сообщениями между веб-приложениями</a></li>
    <li><a href="#ajaxRequests">Проблема AJAX-запросов в GWT при использовании RequestBuilder</a></li>
    <li><a href="#multipleLOBFields">Использование LOB-полей в нескольких модулях</a></li>
    <li><a href="#gxtChart">Использование Gxt-графиков</a></li>
    <li><a href="#listAutoUpdate">Автоматическое обновление списочной формы</a></li>
    <li><a href="#sharedMethodsToParent">Перенос общих методов сервисов и бинов в главный модуль</a></li>
    <li><a href="#customFonts">Поддержка дополнительных шрифтов</a></li>
    <li><a href="#optionsGeneration">Генерация опций для выпадающих списков</a></li>
    <li><a href="#mainView">Основная форма (MainView) приложения</a></li>
    <li><a href="#removeListener">Удаление слушателей событий</a></li>
    <li><a href="#antZip">Использование zip-архиватора с русскими именами файлов</a></li>
    <li><a href="#apachePoi">Работа с документами MS Office с помощью Apache POI</a></li>
    <li><a href="#dialogWindow">Использование модальных диалоговых окон</a></li>
    <li><a href="#browserDependentFeatures">Написание специфичного для браузера кода</a></li>
    <li><a href="#enterModule">Переход на произвольный модуль приложения без перезагрузки хост-страницы</a></li>
    <li><a href="#treeGridManager">Использование древовидной структуры на списочной форме</a></li>
    <li><a href="#sortOptions">Сортировка данных для выпадающих списков</a></li>
    <li><a href="#validation">Использование кастомных валидаторов полей или группы зависимых полей</a></li>
    <li><a href="#messageBoxButton">Возможность установки обработчика событий нажатия на кнопки в наследниках MessageBox</a></li>
    <li><a href="#toolkitUpdate">Создание приложения и расширение сборщика с помощью JepRiaToolkit</a></li>
    <ul>
        <li><a href="#createBlankApplication">Создание «пустой» структуры приложения</a></li>
        <li><a href="#appendBlankModule">Добавление «пустого» модуля к имеющейся структуре приложения</a></li>
        <li><a href="#partialBuildModule">Частичная компиляция и сборка приложения</a></li>
    </ul>
    <li><a href="#buildConfig">Конфигурации сборки</a></li>
    <li><a href="#passwordField">Реализация поля с паролем</a></li>
    <li><a href="#publicPages">Использование public-страниц в приложениях, размещенных на Application-сервере OC4J</a></li>
    <li><a href="#fullLoadingCheck">Проверка полной загрузки данных в цепочке зависимых полей</a></li>
    <li><a href="#cooperationAppWithDB">Взаимодействие App и DB при передаче в качестве параметра списка значений</a></li>
    <li><a href="#noEscapeHtmlInGridCell">Отображение HTML без экранирования в ячейке на списочной форме</a></li>
    <li><a href="#commonJsp">Параметризация главной jsp-страницы приложения, вынесенной в системные ресурсы</a></li>
    <li><a href="#beanValidation">Валидация Java Beans</a></li>
</ul>
<h4><a name="parameterPassing">Передача параметров между модулями приложения</a></h4> При реалиазации некоторых бизнес-задач перед разработчиком встает необходимость передачи параметров между модулями приложения. Существует несколько вариантов решения данной проблемы: использование событий, передающих в качестве параметров необходимые значения; использование атрибутов сессии; определение скрытых полей на
<code>welcome-jsp</code> и т.д. Однако наиболее прозрачным видется решение, основанное на использовании класса-синглтона, существующего в единственном экземпляре в рамках всего приложения.
<br> Описанный синглтон рекомендуется размещать по пути расположения пакета для
<code>JepScope</code> и
<code>JepScopeStack</code> (является также синглтоном). В приведенном ниже примере в качестве передаваемого параметра был выбран объект JepRecord:
<br>
<pre>
package com.technology.&lt;project name&gt;.&lt;application name&gt;.main.client.history.scope;

import com.technology.jep.jepria.shared.record.JepRecord;

public class OutOfStaffAsRiaScope {

  private JepRecord parentCurrentRecord;
  
  public static OutOfStaffAsRiaScope instance = new OutOfStaffAsRiaScope();
  
  public JepRecord getParentCurrentRecord() {
    return parentCurrentRecord;
  }
  
  public void setParentCurrentRecord(JepRecord parentCurrentRecord) {
    this.parentCurrentRecord = parentCurrentRecord;
  }
}
</pre>
<br> В точке инициализации параметров достаточно установить значение поля:
<br>
<pre>
  OutOfStaffAsRiaScope.instance.setParentCurrentRecord(newRecord);
</pre>
<br> В то время как в модулях, где требуется получать данные значения будем использовать соответствующий метод полячения значения:
<br>
<pre>
  JepRecord parentCurrentRecord = OutOfStaffAsRiaScope.instance.getParentCurrentRecord();
</pre>
<h4><a name="parameterPassingBetweenWebApplication">Передача значений между веб-приложениями</a></h4> Периодически перед разработчиком Ria-приложений встает необходимость передачи параметров не только внутри разрабатываемого приложения (
<a href="#parameterPassing">предыдущий раздел</a>), но также критически важным становится взаимодействие с другими приложениями. Одним из способов решения возникшей задачи является использование cookies браузера. Это позволяет хранить необходимую информацию на клиенте, независимо от серверной реализации.
<br> Для работы с cookies в Java важно иметь доступ к объектам HttpServletRequest и HttpServletResponse. При помощи первого (Request) мы считываем имеющиеся значения, а второй (Response) предоставляет возможность их сохранения в браузере.
<br> Рассмотрим конкретную реализацию данных методов (их можно разместить в утильном классе и сделать статическими):
<br>
<pre>
  public class Util {
    /** Метод получения значения из куки, если таковое существует. */
    public static Cookie getCookie(HttpServletRequest request, String cookieName) {
      Cookie[] cookies = request.getCookies();
      if(cookies != null) {
        for(int i = 0; i &lt; cookies.length; i++) {
          Cookie cookie = cookies[i];
          if (cookie.getName().equals(cookieName)
            &amp;&amp; (cookie.getValue() != null)) {
            return cookie;
          }
        }
      }
      return null;
    }
    
    /** Метод записи значения в куки. */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String name, String value) {
      Cookie cookie = new Cookie(name, value);
      cookie.setPath("/"); // Важно: куки должны быть видны различным приложениям (по умолчанию, куки доступны в рамках собственного контекста).
      cookie.setMaxAge(request.getSession().getMaxInactiveInterval()); // Время жизни куки станет равным времени жизни сессии.
      response.addCookie(cookie);
    }

    ...
  }
</pre> Далее реализация зависит от конкретной бизнес-задачи. Опишу случай, с которым пришлось столкнуться в рамках проекта CommissionManagement.
<br> Описание кейса: при выборе/смене направления на формах редактирования (в режиме поиска, добавления, изменения) на других формах пользователю автоматически необходимо отображать последнее выбранное значение.
<br> Стоит заметить, что модуль OutOfStaff реализован с использованием библиотеки JepCommon, в то время как OutOfStaffAsRia - основан на JepRia.
<br> Итак, на форме редактирования в методе onRefresh в классе &lt;Form Name&gt;EditInputAction используем следующий код:
<br>
<pre>
  public void onRefresh(ActionForward[] actionForward, JepSecurityModule jepSecurityModule, JepActionForm form, 
  JepActionForm supForm, ActionMapping mapping, HttpServletRequest request, HttpServletResponse response)
  throws Exception {
  ...
  if(form.getEditMode() == EM_SEARCH || form.getEditMode() == EM_ADD) {
    Cookie directionTypeCookie = Util.getCookie(request, DIRECTION_TYPE_COOKIE_NAME);
    String directionTypeCode = directionTypeCookie == null ? "" : directionTypeCookie.getValue();
    if(!JepDefine.isEmpty(directionTypeCode)) {
      actualAgentDocumentEditForm.setDirectionTypeCode(directionTypeCode);
    }
  }
  ...
  }
</pre> При переходе на списочную форму выбранное значение запоминаем в куках. Нижеприведенный код помещаем в метод onRefresh класса &lt;Form Name&gt;InputAction:
<br>
<pre>
  public void onRefresh(ActionForward[] actionForward, JepSecurityModule jepSecurityModule, JepActionForm form,
  JepActionForm supForm, ActionMapping mapping, HttpServletRequest request, HttpServletResponse response)
  throws Exception {
  ...
  String directionTypeCode = actualAgentDocumentEditForm.getDirectionTypeCode();
  Util.setCookie(request, response, DIRECTION_TYPE_COOKIE_NAME, directionTypeCode);
  ...
  }
</pre> Аналогично, запоминаем значение выбранного направления на формах добавления и редактирования:
<br>
<pre>
  public void onSave(ActionForward[] actionForward, JepSecurityModule jepSecurityModule, JepActionForm form, 
  JepActionForm supForm, ActionMapping mapping, HttpServletRequest request, HttpServletResponse response)
  throws Exception {
  ...
  String directionTypeCode = actualAgentDocumentEditForm.getDirectionTypeCode();
  Util.setCookie(request, response, DIRECTION_TYPE_COOKIE_NAME, directionTypeCode);
  ...
  }
</pre> Для модулей приложения OutOfStaffAsRia поступим следующим образом:
<br>
<ul>
    <li>Определим сервисные методы и соответствующую реализация для получения значений из куки и сохранения его в куки (причем данный код рекомендуется размещать в главном модуле приложения, как это показано <a href="#sharedMethodsToParent">здесь</a>):<br> <pre>
       @RemoteServiceRelativePath("OutOfStaffAsRiaService")
      public interface OutOfStaffAsRiaService extends JepDataService {
        ...
        JepOption getDirectionTypeFromCookie() throws ApplicationException;
        void setDirectionTypeToCookie(JepOption directionTypeOption) throws ApplicationException;
        ...
      }
    </pre> <pre>
      public interface OutOfStaffAsRiaServiceAsync extends JepDataServiceAsync {
        ...
        void getDirectionTypeFromCookie(AsyncCallback&lt;JepOption&gt; callback);
        void setDirectionTypeToCookie(JepOption directionTypeOption, AsyncCallback&lt;Void&gt; callback);
        ...
      }
    </pre> <pre>
      public abstract class OutOfStaffAsRiaServiceImpl extends JepDataServiceServlet implements OutOfStaffAsRiaService {
        ...
        /** Метод получения значения "Направления" из куков. */
        public JepOption getDirectionTypeFromCookie() throws ApplicationException {
          List&lt;JepOption&gt; directionTypeList = getDirectionType();
          Cookie directionTypeCookie = getCookieWithGivenName(DIRECTION_TYPE_COOKIE_NAME);
          String directionTypeCode = directionTypeCookie == null ? null : directionTypeCookie.getValue(); 
          if(!JepRiaUtil.isEmpty(directionTypeCode)) {
            for(JepOption option : directionTypeList) {
              if(option.getValue().equals(directionTypeCode)) {
                return option;
              }
            }
          }
          return null;
        }

        /** Метод сохранения значения "Направления" в куки. */
        public void setDirectionTypeToCookie(JepOption directionTypeOption) throws ApplicationException {
          if(!JepRiaUtil.isEmpty(directionTypeOption) &amp;&amp; !JepRiaUtil.isEmpty(directionTypeOption.getValue())) {
            setCookie(getThreadLocalRequest(), getThreadLocalResponse(), DIRECTION_TYPE_COOKIE_NAME, directionTypeOption.getValue().toString());
          }
        }

        /** Извлечение значения куки с указанным именем. */
        private Cookie getCookieWithGivenName(String cookieName) {
          Cookie[] cookies = getThreadLocalRequest().getCookies();
          if(cookies != null) {
            for(int i = 0; i &lt; cookies.length; i++) {
              Cookie cookie = cookies[i];
              if(cookie.getName().equals(cookieName)
                  &amp;&amp; !JepRiaUtil.isEmpty(cookie.getValue())) {
                return cookie;
              }
            }
          }
          return null;
        }

        /** Сохранение куков в браузере. */
        private void setCookie(HttpServletRequest request, HttpServletResponse response, String name, String value) {
          Cookie cookie = new Cookie(name, value);
          cookie.setPath("/");
          cookie.setMaxAge(request.getSession().getMaxInactiveInterval());
          response.addCookie(cookie);
        }
      ...
      }
    </pre> </li>
    <li>Определим DetailFormPresenter в главном модуле, в котором будут извлекаться значения "Направления" и сохраняться:<br> <pre>
      public class OutOfStaffAsRiaDetailFormPresenter&lt;E extends PlainEventBus, V extends JepDetailFormView, S extends OutOfStaffAsRiaServiceAsync, C extends JepClientFactory&lt;E, S&gt;&gt; 
        extends JepDetailFormPresenter&lt;E, V, S, C&gt; {
        
        private S service = clientFactory.getService();
        
        public OutOfStaffAsRiaDetailFormPresenter(JepWorkstatePlace place,
            C clientFactory) {
          super(place, clientFactory);
        }
        
        public OutOfStaffAsRiaDetailFormPresenter(String[] modules, JepWorkstatePlace place,
            C clientFactory) {
          super(modules, place, clientFactory);
        }

         @Override
        protected void adjustToWorkstate(WorkstateEnum workstate) {
          super.adjustToWorkstate(workstate);
          
          if (SEARCH.equals(workstate) || CREATE.equals(workstate)){
            ((MainViewImpl)MainViewImpl.instance).mask(JepTexts.loadingPanel_dataLoading());
            service.getDirectionTypeFromCookie(new JepAsyncCallback&lt;JepOption&gt;() {
              public void onSuccess(JepOption result) {
                fields.setFieldValue(DIRECTION_TYPE_CODE, result);
                ((MainViewImpl)MainViewImpl.instance).unmask();
              }
              public void onFailure(Throwable th){
                ((MainViewImpl)MainViewImpl.instance).unmask();
              }
            });
          }
        }
        
         @Override
        public void onSearch(SearchEvent event) {
          super.onSearch(event);
          service.setDirectionTypeToCookie((JepOption) fields.getFieldValue(DIRECTION_TYPE_CODE), new JepAsyncCallback&lt;Void&gt;() {
            public void onSuccess(Void result) {
            }
          });
        }
        
         @Override
        protected void afterSave(JepRecord resultRecord) {
          super.afterSave(resultRecord);
          service.setDirectionTypeToCookie((JepOption) fields.getFieldValue(DIRECTION_TYPE_CODE), new JepAsyncCallback&lt;Void&gt;() {
            public void onSuccess(Void result) {
            }
          });
        }
      }
    </pre> И для тех GWT-модулей, где необходимо получение значения о направлении брать из cookies, мы унаследовываем &lt;Form Name&gt;DetailFormPresenter от OutOfStaffAsRiaDetailFormPresenter и переопределяем метод adjustToWorkstate:<br> <pre>
       @Override
      protected void adjustToWorkstate(WorkstateEnum workstate) {
        super.adjustToWorkstate(workstate);
        //TODO: your business-code;
      }
    </pre> </li>
</ul> Удобство использования cookies очевидно при взаимодействии приложений, однако и не стоит забывать и об ограничениях, которые на них накладываются (в частности, размер передаваемых значений). Поэтому данная реализация может оказаться неподходящей в отдельных случаях.
<h4><a name="postMessageBetweenWebApplication">Кросс-доменный обмен сообщениями между веб-приложениями</a></h4> При попытке интегрирования RIA-приложений во внешние системы (CRM, сайт "Русфинанс банк" и т.д.) зачастую возникает потребность в коммуникации клиентских частей, предоставляя возможность обмена сообщениями между приложениями, фактически расположенных в различных доменах. По умолчанию, политика безопасности современных браузеров пресекает возможности чтения данных из источников, домен которых отличен от текущего приложения (механизм cookies, глобальные js-переменные и прочее).
<br> Однако с появлением HTML5 для решения проблемы кросс-доменной коммуникации добавлена возможность общения окон и фреймов с разных доменов. Такая возможность представлена интерфейсом
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank">postMessage</a>, который очень удобен, например, для взаимодействия внешних виджетов и сервисов, подключённых через фрейм с основной страницей.
<br> Итак, рассмотрим пример, как организовать такой односторонний канал взаимодействия между основной страницей и интегрируемым RIA-приложением. Стоит обратить внимание, что взаимодействие можно организовать и двусторонним, о чем будет сказано чуть позже. Представим, что на host-странице parent-приложения где-то в DOM-дереве имеется такой узел:
<pre>
&lt;iframe src="<em>&lt;ссылка_на_встраиваемое_RIA_приложение&gt;</em>" id="childFrame"&gt;&lt;/iframe&gt;
</pre> В рассматриваемом случае предполагается, что основное приложение является источником данных и предоставляет встраиваемому модулю некую дополнительную информацию, критичную для его работы. В качестве формата данных, рекомендуется использовать JSON, который легко может быть приведен сконвертирован к строковому виду и обратно. Для организации канала взаимодействия воспользуемся указанной ранее функциональностью HTML5. Для этого на основной странице в блоке определения js-скриптов следует добавить запись:
<pre>
&lt;script&gt;
        ...
        window.onload = function(){
                document.getElementById("childFrame").contentWindow.postMessage('желаемые данные', 'https://wwww.rusfinancebank.ru');
        };
&lt;/script&gt;
</pre> Обратите внимание, что функция postMessage принимает два параметра: первый - это передаваемое сообщение-объект (в IE допускается передача только строковых значений), второй - указание домена, от имени которого будет отправлено сообщение встраиваемому модулю (если значение *, то отправка допускается с любого домена).
<br> На стороне отправителя-инициатора для взаимодействия уже описаны все необходимые действия. Следует обратить внимание лишь на тот факт, что отправка сообщения должна происходить уже после полной готовности DOM-дерева (в приведенном примере, по событию загрузки страницы и готовности фрейма). Аналогично, можно данный вызов осуществлять, например, по нажатию на кнопки, потере фокуса и прочим js-событиям.
<br>
<br> Теперь встает задача приема этих сообщений. Для этого на host-странице встраиваемого приложения в блоке скриптов должны быть определены соответствующие прослушиватели:
<pre>
&lt;script type="text/javascript"&gt;
var json;
function listener(event) {
  if (event.origin != 'https://wwww.rusfinancebank.ru') {
    // что-то прислали с неизвестного домена - проигнорируем..
    return;
  }
  json = event.data;
}

if (window.addEventListener) {
  window.addEventListener("message", listener);
} else {
  // IE8
  window.attachEvent("onmessage", listener);
}
&lt;/script&gt;
</pre> В данном случае, принимаемые данные сохраняются в переменную
<em>json</em> и будут считаны из прикладного модуля. Для этих целей отлично подходит механизм JSNI, позволяющий получать доступ к внешним js-переменным из GWT-приложения. Для этого в прикладном коде, например, в классе
<em>ModulePresenter</em> или
<em>DetailFormPresenter</em> следует определить два метода:
<pre>
private native void injectEventListener() /*-{
  this.@&lt;fully_qualified_class_name&gt;ModulePresenter::eventListener(Ljava/lang/String;)($wnd['json']);
}-*/;

public void eventListener(String message){
  // логика обработки полученного сообщения
}
</pre> Вызов метода
<em>injectEventListener</em> следует выполнить там, где требуется реакция на обработку сообщения.
<br>
<br> Данная возможность коммуникации сторон наряду с альтернативными (CORS, проксирование запросов и т.д.) достаточно легка в реализации. При этом задержки между отправкой и получением вовсе отсутствуют (в противоположность даже вызову setTimeout с минимальной 4мс задержкой), а также предусмотрены средства для обеспечения проверок безопасности (например, ограничивая список допускаемых к взамодействию доменов). Несмотря на то, что данный метод postMessage предусмотрен для объектов window для 100% работоспособности его все же следует применять исключительно для взаимодействия iframe (в IE данная функциональность не работает для окон и табов).
<br> Как уже было сказано ранее, допустимо и обратная отправка сообщения родительскому приложению. Тогда функция listener примет вид:
<pre>
function listener(event) {
  if (event.origin == 'https://wwww.rusfinancebank.ru') {
        if (event.data == 'Hello World') {
        event.source.postMessage('Hello', '*');
    } else {
        json = event.data;
    }
  }
}
</pre>
<h4><a name="ajaxRequests">Проблема AJAX-запросов в GWT при использовании RequestBuilder</a></h4> Создатели фреймворка GWT в качестве основы механизма клиент-серверного взаимодействия заложили технологию GWT-RPC. Она обладает достаточным количеством преимуществ, поэтому для большинства случаев для обращения к серверной части используются RPC-сервисы.
<br> Однако для коммуникации сторон одной возможностью не стали ограничиваться и в GWT также имеется поддержка ajax-запросов средствами класса <code>RequestBuilder</code>, пример использования которого ниже:
<pre>
RequestBuilder rBuilder = new RequestBuilder(method, URL.encode(requestUrl));
try {
        rBuilder.sendRequest(null, callback);
}
catch(RequestException exception){
        showError(exception.getMessage());
}
</pre>,
<br>где в качестве параметра
<em>method</em> можно использовать доступные для HTTP-протокола методы доступа (GET, POST, PUT, DELETE, HEAD (константы этого класса)), а в качестве
<em>callback</em> используется ссылка на интерфейс <code>RequestCallback</code> с переопределенными методами <code>RequestCallback.onResponseReceived(com.google.gwt.http.client.Request, com.google.gwt.http.client.Response)</code> и <code>RequestCallback.onError(com.google.gwt.http.client.Request, java.lang.Throwable)</code>.
<br> Если взаимодействие осуществляется на основе формата данных JSON, то для взаимодействия (даже кросс-доменного) также возможен вариант использования реализации класса <code>com.google.gwt.jsonp.client.JsonpRequestBuilder</code>.
<br> Данный подход корректно работает, если запрашиваемый requestUrl вызывается единажды или его значение меняется. Проблема в данном случае происходит в связи с тем, что Internet Explorer использует кэширование в том числе и ajax-запросов.
<br> Для решения проблем IE существует два подхода:
<ol>
    <li>В конец запрашиваемой ссылки добавляется случайный незначащий параметр со значением, меняющимся от вызова к вызову (например, параметр rand со значением, сгенерированным Math.random())</li>
    <li>Добавить заголовок запроса "If-Modified-Since" со значением "01 Jan 1970 00:00:00 GMT"</li>
</ol> Первый случай предпочтителен, когда нет возможности изменять заголовки запроса, в противном случае - лучше использовать второй способ во избежании проблем добавления параметра запроса (обрабатывать ситуацию, когда requestUrl содержит или не содержит параметры). Тогда, код примет вид:
<pre>
RequestBuilder rBuilder = new RequestBuilder(method, URL.encode(requestUrl));
try {
        rBuilder.setHeader("If-Modified-Since", "01 Jan 1970 00:00:00 GMT");
        rBuilder.sendRequest(null, callback);
}
catch(RequestException exception){
        showError(exception.getMessage());
}
</pre>
<br>
<h4><a name="multipleLOBFields">Использование LOB-полей в нескольких модулях</a></h4> По умолчанию, при генерации приложения, модуль которого содержит LOB-поля, в дескрипторе развёртывания web.xml сервлеты для загрузки/выгрузки прописываются следующим образом:
<pre>
&lt;servlet&gt;
  &lt;servlet-name&gt;downloadServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.server.DownloadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;downloadServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/download&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;uploadServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.server.UploadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;uploadServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/upload&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre> Однако это приводит к проблемам, когда функционал загрузки/выгрузки используется в нескольких модулях одного приложения, поскольку в дескрипторе развёртывания таким образом оказывается прописанным лишь один сервлет.
<br> Решение в данной ситуации следующее. Пусть, например, два модуля Module1 и Module2 используют
<i>выгрузку</i> файлов. Тогда, во-первых, дадим этим сервлетам различные имена и пропишем их на разные URL:
<pre>
&lt;servlet&gt;
  &lt;servlet-name&gt;downloadServletModule1&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name 1&gt;.server.DownloadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;downloadServletModule1&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/downloadModule1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;downloadServletModule2&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name 2&gt;.server.DownloadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;downloadServletModule2&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/downloadModule2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre> Этого, однако, недостаточно, поэтому, во-вторых, требуется в представлении (view) детальной формы переопределить метод buildDownloadUrl(), возвращающий URL, по которому скачивается файл. В модуле Module1 это будет выглядеть следующим образом:
<pre>
public class Module1DetailFormView extends JepDetailFormViewImpl 
  implements JepDetailFormView {
    public Module1DetailFormView() {
    . . .
    JepFileField fileField = new JepFileField(module1Text.module1_detail_file_field_name()){
      
         @Override
        protected String buildDownloadUrl(Object reference) {
          String originalURL = super.buildDownloadUrl(reference);
          if (originalURL == null) {
            return originalURL;
          }
          String modifiedURL = originalURL.replace("download", "downloadModule1");
          return modifiedURL;
        }
      }
}
</pre> Для
<i>загрузки</i> в web.xml вносятся аналогичные изменения:
<pre>
&lt;servlet&gt;
  &lt;servlet-name&gt;uploadServletModule1&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name 1&gt;.server.UploadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;uploadServletModule1&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/uploadModule1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;uploadServletModule2&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.technology.rfi.&lt;application name&gt;.&lt;module name 2&gt;.server.UploadServiceImpl&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;uploadServletModule2&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;Application Name&gt;/uploadModule2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre> В код представления детальной формы вносится следующее дополнение:
<pre>
public class Module1DetailFormView extends JepDetailFormViewImpl 
  implements JepDetailFormView {
    public Module1DetailFormView() {
      . . .
      JepFileField fileField = . . .
      FormPanel fileFormPanel = fileField.getFormPanel(); 
      fileFormPanel.setAction(GWT.getModuleBaseURL() + "uploadModule1");
    }
}
</pre> Для Module2 все вносимые изменения аналогичны.
<br>
<h4><a name="gxtChart">Использование Gxt-графиков</a></h4> Для отрисовки графиков непосредственно на форме (детальной либо списочной) используются встроенная в Gxt библиотека Charts. Данная библиотека обладает достаточно богатыми возможностями в области визуализации данных, в том числе построения графиков, круговых и линейчатых диаграмм и т.д. Ознакомиться с примерами использования можно в демонстрации Gxt 2.2.3 Explorer демо, в данном же разделе ограничимся примером внедрения диаграммы в прикладной модуль на основе JepRia. В примере рассмотрим отображение простейшей диаграммы на форме детального просмотра.
<br>
<br> Если в модуле используется построение графиков, в его файл Module XML необходимо включить ссылку на Gxt Charts:
<pre>
  &lt;inherits name='com.extjs.gxt.charts.Chart' /&gt;
</pre> В текущей используемой версии Gxt 2.2.3 для отрисовки графиков в приложение внедряется объект Flash. Для управления объектами Flash используется JavaScript-библиотека SWFObject. В связи с этим в блок &lt;HEAD&gt; JSP-файла приложения &lt;Application Name&gt;.jsp необходимо добавить следующую строку:
<pre>
  &lt;script language='javascript' src='&lt;Application Name&gt;/gxt/flash/swfobject.js'&gt;&lt;/script&gt;
</pre> Виджет графика необходимо добавить в представление (view). Будем рассматривать добавление графика на детальную форму, но ничто не мешает аналогичным образом добавить его на списочную форму. Также необходимо добавить в представление методы управления графиком извне (то есть из презентера):
<pre>
package com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.client.ui.form.detail;

/*
 * стандартные импорты JepRia, GWT и Gxt
 */
. . .

import com.extjs.gxt.charts.client.Chart;
import com.extjs.gxt.charts.client.ChartManager;
import com.extjs.gxt.charts.client.model.ChartModel;
import com.extjs.gxt.ui.client.widget.LayoutContainer;
import com.extjs.gxt.ui.client.widget.flash.SwfObject.SwfConfig;
 
public class &lt;ModuleName&gt;DetailFormView extends JepDetailFormViewImpl 
  implements JepDetailFormView {
  
  private Chart chart;
 
  public &lt;ModuleName&gt;DetailFormView() {
    super(new FieldManager());    
    LayoutContainer container = new StandardLayoutContainer();
 
    /*
     * Стандартный код, создающий поля и добавляющий их в FieldManager
     */
    . . .
    
    createChart(container);
    container.layout();
  }

  private void createChart(LayoutContainer container) {
    String url = GWT.getModuleBaseURL() + "gxt/chart/open-flash-chart.swf";
    chart = new Chart(url) {

      /*
       * Задаём текст, отображаемый при отсутствии Flash Player.
       */
       @Override
      protected void onAttach() {
        ChartManager.get().registerChart(this);
          el().setInnerHtml("&lt;div id=\"" + getSwfId() + "\"&gt;&lt;h1&gt;График не может быть показан, так как Flash Player не установлен или отключён.&lt;/h1&gt;&lt;/div&gt;");
          SwfConfig config = new SwfConfig();
          injectFlash(config);
      }
      
    };
    chart.setBorders(true); // добавление рамки (необязательно)
    container.add(chart);
  }
  
  /*
   * Связывание виджета с моделью.
   */
  public void setChartModel(ChartModel model) {
    chart.setChartModel(model);
  }
  
  /*
   * Отображение/скрытие виджета графика.
   */
  public void setChartVisible(boolean visible) {
    chart.setVisible(visible);
  }
 
}
</pre> Основные манипуляции по построению графика осуществляются в презентере. В реальной задаче данные для построения графика запрашиваются у сервера, поэтому необходимо добавление соответствующих методов в сервис и бин модуля. Однако в данном простом примере данные генерируются случайным образом при каждом посещении формы детального просмотра. Отображать график будем только на форме детального просмотра. Код презентера имеет следующий вид:
<pre>
package com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.client.ui.form.detail;

/*
 * Стандартные импорты JepRia, GWT и Gxt
 */
. . .

import com.extjs.gxt.charts.client.model.ChartModel;
import com.extjs.gxt.charts.client.model.axis.XAxis;
import com.extjs.gxt.charts.client.model.axis.YAxis;
import com.extjs.gxt.charts.client.model.charts.FilledBarChart;
import com.google.gwt.user.client.Random;

public class &lt;ModuleName&gt;DetailFormPresenter&lt;E extends PlainEventBus, S extends TestModuleServiceAsync&gt; 
    extends JepDetailFormPresenter&lt;E, &lt;ModuleName&gt;DetailFormView, S, JepClientFactory&lt;E, S&gt;&gt; { 
 
  /*
   * Конструктор и метод bind(), а также остальные стандартные методы остаются без изменений.
   */
  . . .
 
  protected void adjustToWorkstate(WorkstateEnum workstate) {
    
    /*
     * Управление отображением и сокрытием полей модуля.
     */
    . . .
    
    view.setChartVisible(VIEW_DETAILS.equals(workstate));
    
    if (VIEW_DETAILS.equals(workstate)) {
      view.setChartModel(updateChartModel());
    }
  }

  private ChartModel updateChartModel() {
    /*
     * В данном простом примере диаграмма создаётся на основе данных,
     * генерируемых случайным образом. В реальной задаче диаграмма
     * будет формироваться на основании полученных от сервера данных.
     */
    ChartModel cm = new ChartModel("Ежемесячные продажи",
        "font-size: 16px; font-weight: bold; font-family: Verdana; color:#008800;");
    cm.setBackgroundColour("#eeffee");
    cm.setDecimalSeparatorComma(true);
    XAxis xa = new XAxis();
    List&lt;String&gt; labels = new ArrayList&lt;String&gt;();
    labels.add("Январь");
    labels.add("Февраль");
    labels.add("Март");

    xa.setLabels(labels);
    xa.getLabels().setColour("#009900");
    xa.setGridColour("#eeffee");
    xa.setColour("#009900");
    cm.setXAxis(xa);
    YAxis ya = new YAxis();
    ya.setRange(5000, 20000);
    ya.setSteps(1000);
    ya.setGridColour("#eeffee");
    ya.setColour("#009900");
    cm.setYAxisLabelStyle(10, "#009900");
    cm.setYAxis(ya);
    FilledBarChart bchart = new FilledBarChart("#6666ff", "#000066");
    bchart.setTooltip("#val# млн. руб.");
    for (int t = 0; t &lt; 3; t++) {
      bchart.addValues(Random.nextInt(5000) + 10000);
    }
    cm.addChartConfig(bchart);
    return cm;
  }
  
}
</pre>
<h4><a name="listAutoUpdate">Автоматическое обновление списочной формы</a></h4> В JepRia предусмотрена возможность автоматически обновлять списочную форму через заданные промежутки времени (например, 20 секунд). В первую очередь это касается прикладных модулей, использующих TaskProcessor.
<br>
<br> Общий алгоритм включения автоматического обновления следующий. Во-первых, требуется модифицировать метод find() бина (класс
<i>ModuleName</i>Bean), передав ему объект класса AutoRefreshResultSetMapper. Рассмотрим пример:
<br>
<pre>
package com.technology.rfi.clientndflconvertor.loadtask.server.ejb;
   
 @Local( { LoadTaskLocal.class })
 @Remote( { LoadTaskRemote.class })
 @StatelessDeployment
 @Stateless
public class LoadTaskBean extends ClientNdflConvertorBean implements LoadTask {
 
  public LoadTaskBean() {
    super(DATA_SOURCE_JNDI_NAME, RESOURCE_BUNDLE_NAME);
  }
 
   @Override
  public List&lt;JepRecord&gt; find(
      JepRecord templateRecord,
      Mutable&lt;Boolean&gt; autoRefreshFlag,
      Integer maxRowCount,
      Integer operatorId)
      throws ApplicationException {
    String sqlQuery = ... ;
    return super.find( sqlQuery,
        new AutoRefreshResultSetMapper&lt;JepRecord&gt;(autoRefreshFlag, new ResultSetMapper&lt;JepRecord&gt;() {
            public void map(ResultSet rs, JepRecord record) throws SQLException {
              . . .
              // Стандартные манипуляции с результирующим набором и записью.
            }
        }) {
          public boolean isRefreshNeeded(ResultSet rs) throws SQLException {
            String loadTaskStatusCode = rs.getString(LOAD_TASK_STATUS_CODE);
            return !("COMPLETE".equals(loadTaskStatusCode) || "ERROR".equals(loadTaskStatusCode));
          }}
        , ... // Параметры поиска.
        );
    
    // Остальные методы остаются без изменений.
    
  }
}
</pre> Остановимся подробнее на классе AutoRefreshResultSetMapper. Данный класс использует паттерн Decorator и является обёрткой для ResultSetMapper, в связи с чем второй параметр его конструктора — объект класса ResultSetMapper. В качестве первого обязательно передавать параметр метода find() — autoRefreshFlag.
<br>
<br> Абстрактный метод isRefreshNeeded() содержит проверку условия автообновления должен возвращать истину, если обновление необходимо, и ложь в противном случае. Данный метод обязательно должен быть переопределён. Если необходимо, чтобы автообновление выполнялось во всех случаях, достаточно определить метод следующим образом:
<pre>
public boolean isRefreshNeeded(ResultSet rs) throws SQLException {
  return true;
}
</pre> В приведённом выше примере обновление выполнится, если хотя бы одна из задач, возвращённых методом find(), имела иной код статуса, кроме "COMPLETE" или "ERROR".
<br>
<br>Во-вторых, требуется унаследовать в презентере списочной формы (
<i>ModuleName</i>ListFormPresenter) класс AutoRefreshListFormPresenter. При этом в конструкторе можно задать интервал автоматического обновления в миллисекундах:
<pre>
package com.technology.rfi.clientndflconvertor.loadtask.client.ui.form.list;

public class LoadTaskListFormPresenter&lt;E extends PlainEventBus, S extends LoadTaskServiceAsync&gt; 
  extends AutoRefreshListFormPresenter&lt;E, LoadTaskListFormViewImpl, S, JepClientFactory&lt;E, S&gt;&gt; {

  public LoadTaskListFormPresenter(JepWorkstatePlace place, JepClientFactory&lt;E, S&gt; clientFactory) {
    super(place, clientFactory);
    super.setRefreshDelay(10000); // Автообновление каждые десять секунд.
  }
  
  // Далее без изменений.
   
}
</pre> Добавим, что в модулях, использующих TaskProcessor, имеет смысл после создания задачи переходить не на детальную форму, как это делается по умолчанию, а на списочную.
<br>
<h4><a name="sharedMethodsToParent">Перенос общих методов сервисов и бинов в главный модуль</a></h4> Нередко возникает ситуация, когда несколько модулей используют одинаковые методы получения данных из базы. Типичный пример – извлечение списка опций для раскрывающегося списка. Чтобы не возникало дублирования кода со всеми вытекающими последствиями, требуется перенести их в сервис главного модуля. Для этого требуется в модуле main создать иерархию классов и интерфейсов, которые будут наследоваться соответствующими классами и интерфейсами дочерних модулей.
<br>
<br> Требуется выполнить следующие действия (будем рассматривать на примере приложения TimeSheetAsRia):
<ol>
    <li>Создать интерфейсы для сервиса модуля main (здесь и далее импорты будем опускать).<br> <b>Интерфейс com.technology.rfi.timesheetasria.main.shared.service.TimeSheetAsRiaService</b> <pre>
package com.technology.rfi.timesheetasria.main.shared.service;
 
 @RemoteServiceRelativePath("TimeSheetAsRiaService")
public interface TimeSheetAsRiaService extends JepDataService {
  // TODO
}
</pre> <b>Интерфейс com.technology.rfi.timesheetasria.main.shared.service.TimeSheetAsRiaServiceAsync</b> <pre>
package com.technology.rfi.timesheetasria.main.shared.service;
 
public interface TimeSheetAsRiaServiceAsync extends JepDataServiceAsync {
  //TODO 
}

</pre> </li>
    <li>Создать родительский класс для реализации сервиса <br> <b>Класс com.technology.rfi.timesheetasria.main.server.TimeSheetAsRiaServiceImpl</b> <pre>
package com.technology.rfi.timesheetasria.main.server;
 
 @RemoteServiceRelativePath("TimeSheetAsRiaService")
public class TimeSheetAsRiaServiceImpl extends JepDataServiceServlet implements TimeSheetAsRiaService  {
 
  private static final long serialVersionUID = 1L;
 
  public TimeSheetAsRiaServiceImpl(JepRecordDefinition recordDefinition, String ejbName) {
    super(recordDefinition, ejbName);
  }
 
  //TODO сюда переносим методы из сервисов дочерних модулей
}

</pre> </li>
    <li>Создать класс для констант. <br> <b>Класс com.technology.jep.jepria.server.JepRiaServerConstant</b> <pre>
package com.technology.rfi.timesheetasria.main.server;
 
public class TimeSheetAsRiaServerConstant extends JepRiaServerConstant {
  // TODO
}
</pre> </li>
    <li>Создать родительский класс и интерфейсы для бинов.<br> <b>Интерфейс com.technology.rfi.timesheetasria.main.shared.service.TimeSheetAsRia</b> <pre>
package com.technology.rfi.timesheetasria.main.shared.service;
 
public interface TimeSheetAsRia extends JepDataStandard {
  // TODO
}
</pre> <b>Класс com.technology.rfi.timesheetasria.main.server.ejb.TimeSheetAsRiaBean</b> <pre>
package com.technology.rfi.timesheetasria.main.server.ejb;
 
 @Local( { TimeSheetAsRiaLocal.class })
 @Remote( { TimeSheetAsRiaRemote.class })
 @StatelessDeployment
 @Stateless
public class TimeSheetAsRiaBean extends JepDataStandardBean implements TimeSheetAsRia {{

   @Resource
  SessionContext sessionContext;
  
  public TimeSheetAsRiaBean(String dataSourceJndiName, String resourceBundleName) {
    super(dataSourceJndiName, resourceBundleName);
  }

  public List&lt;JepRecord&gt; find(JepRecord templateRecord, Integer maxRowCount,
      Integer operatorId) throws ApplicationException {
    throw new UnsupportedOperationException();
  }

  public Object create(JepRecord record, Integer operatorId)
      throws ApplicationException {
    throw new UnsupportedOperationException();
  }

  public void update(JepRecord record, Integer operatorId)
      throws ApplicationException {
    throw new UnsupportedOperationException();    
  }

  public void delete(JepRecord record, Integer operatorId)
      throws ApplicationException {
    throw new UnsupportedOperationException();    
  }

  // TODO перенести сюда методы из бина дочернего модуля

}
</pre> <b>Интерфейс com.technology.rfi.timesheetasria.main.server.ejb.TimeSheetAsRiaLocal</b> <pre>
package com.technology.rfi.timesheetasria.main.server.ejb;

import com.technology.rfi.timesheetasria.main.shared.service.TimeSheetAsRia;
 
 @Local
public interface TimeSheetAsRiaLocal extends TimeSheetAsRia {
}
</pre> <b>Интерфейс com.technology.rfi.timesheetasria.main.server.ejb.TimeSheetAsRiaRemote</b> <pre>
package com.technology.rfi.timesheetasria.main.server.ejb;
 
 @Remote
public interface TimeSheetAsRiaRemote extends TimeSheetAsRia {
}
</pre> </li>
    <li>Унаследовать в дочерних модулях все классы и интерфейсы в пакете com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.shared.service от соответствующих классов и интерфейсов главного модуля. </li>
    <li>Унаследовать в бинах дочерних модулей бин главного модуля.</li>
    <li>Унаследовать в реализации сервиса дочернего модуля (&lt;ModuleName&gt;ServiceImpl) реализацию сервиса родительского модуля.</li>
    <li>Перенести из дочерних классов и интерфейсов в родительские определения и реализации общих методов.</li>
    <li>Перенести необходимые классы *Options из пакетов com.technology.rfi.&lt;application name&gt;.&lt;module name&gt;.shared.field в пакет com.technology.rfi.&lt;application name&gt;.main.shared.field.</li>
</ol>
<b>ВНИМАНИЕ:</b> При переносе методов необходимо следить за тем, чтобы в классах и интерфейсах главного модуля не оставалось зависимостей от дочерних модулей!
<br>
<h4><a name="customFonts">Поддержка дополнительных шрифтов</a></h4> Для использования в отчетах пользовательских шрифтов необходимо:
<br>
<ol>
    <li>В &lt;resource-home&gt; создать папку fonts.</li>
    <li>Скопировать в неё все .ttf файлы нужных шрифтов и их вариантов начертания (полужирный, курсив и т.п.) – обычно находятся в папке …\Windows\Fonts</li>
    <li>Создать в &lt;resource home&gt;\fonts\ файл <b>&lt;module name&gt;-fonts.xml</b> (ниже - на примере шрифта Verdana): <pre>
      &lt;?xml version="1.0" encoding="UTF-8"?&gt;

      &lt;beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;

      &lt;!-- Секция &lt;bean&gt;...&lt;/bean&gt; повторяется для всех шрифтов, которые необходимо включить в коллекцию. --&gt;
      &lt;bean id="verdanaFamily" class="net.sf.jasperreports.engine.fonts.SimpleFontFamily"&gt;
        &lt;property name="name" value="Verdana"/&gt;
        &lt;property name="normal" value="verdana.ttf"/&gt;
        &lt;property name="italic" value="verdanai.ttf"/&gt;
        &lt;property name="bold" value="verdanab.ttf"/&gt;
        &lt;property name="boldItalic" value="verdanaz.ttf"/&gt;
        &lt;property name="pdfEncoding" value="Cp1251"/&gt;
        &lt;property name="pdfEmbedded" value="true"/&gt;
      &lt;/bean&gt;
      &lt;/beans&gt;
    </pre> </li>
    <li>Создать в &lt;resource home&gt;\fonts\ файл <b>jasperreports_extension.properties</b>: <pre>
      net.sf.jasperreports.extension.registry.factory.fonts=net.sf.jasperreports.extensions.SpringExtensionsRegistryFactory
      net.sf.jasperreports.extension.fonts.spring.beans.resource=&lt;module name&gt;-fonts.xml
    </pre> </li>
</ol> При сборке проекта будет создан файл
<b>&lt;module name&gt;-fonts.jar</b> и добавлен в ear\lib.
<br>
<br> Обратите внимание следующие моменты:
<br>
<br>
<ul>
    <li>Набор вариантов начертаний (bold, italic, boldItalic) у разных шрифтов может различаться.</li>
    <li>Необходимо внимательно указывать названия файлов с вариантами начертания шрифта, т.к. суффиксы у одинаковых начертаний разных шрифтов могут отличаться (например, полужирный наклонный Verdana называется verdanaz.ttf, а полужирный наклонный Arial - arialbi.ttf).</li>
    <li>Пользовательские шрифты не заменяют системный набор (Arial, Times New Roman, Courier New, Verdana), а дополняют его.</li>
</ul>
<h4><a name="optionsGeneration">Генерация опций для выпадающих списков</a></h4> В некоторых случаях нецелесообразно нагружать DB-интерфейс функциями, генерирующими опции для выпадающих списков, - например, для списка дней недели или месяцев. В этом случае данный список может быть сгенерирован на App-части. Для того, чтобы не делать это вручную, можно воспользоваться фабричным методом JepOption.buildListFromToken(), который принимает на вход строку специального вида - history token. В данной строке значение и имя опции разделяются с помощью последовательности символов $c$, а опции - последовательностью $l$. Таким образом, списку опций «0 - Нет, 1 - Да» будет соответствовать следующий токен: 0$c$Нет$l$1$c$Да. Токены для списков необходимо размещать в текстовых ресурсах. В текстовых ресурсах JepRia (файлы JepRiaText_Source.properties, JepRiaText_en.properties и соответствующем им интерфейсе JepRiaText) предусмотрены токены для некоторых стандартных опций (да-нет, дни недели, месяцы).
<br>
<br> Рассмотрим генерацию стандартного списка опций на примере рассмотренного выше списка «0 - Нет, 1 - Да». Заметим, что достоинством данного подхода является возможность его применения как на стороне сервера (в бине или сервисе), так и на клиентской части. В бине это будет выглядеть следующим образом:
<pre>
  import static com.technology.jep.jepria.server.JepRiaServerConstant.JEP_RIA_RESOURCE_BUNDLE_NAME;
  ...
  public class ExampleBean ... {
    ...
    public List&lt;JepOption&gt; getYesNo() throws ApplicationException {

      ResourceBundle bundle = ResourceBundle.getBundle(JEP_RIA_RESOURCE_BUNDLE_NAME);
      String yesNoToken = bundle.getString("form.detail.option.token.yesNo");
      return JepOption.buildListFromToken(yesNoToken);
    }

  }
</pre> На стороне интерфейса список опций генерируется следующим кодом:
<pre>
  import static com.technology.jep.jepria.client.JepRiaClientConstant.JepTexts;
  ...
  public class ExampleDetailFormPresenter . . . {
    ...
     @Override
    protected void bind() {
      ...
      List&lt;JepOption&gt; yesNoOptions = JepOption.buildListFromToken(JepTexts.form_detail_option_token_yesNo());
      fields.setFieldOptions(EXAMPLE_YES_NO_FIELD, yesNoOptions);
    }
  }
</pre>
<h4><a name="mainView">Основная форма (MainView) приложения</a></h4> Данная форма представляет собой аналог
<strong>RootPanel</strong> для приложений, написанных с использованием JepRia. Для стандартных приложений на ней обычно располагаются инструментальная панель, контейнер элементов формы, статусбар, списочная форма, а также кнопка выхода и логин авторизовавшегося пользователя. Основная форма едина для всех модулей приложения и отлично подходит для реализации дополнительных возможностей, позволяющих проектировать user-fiendly интерфейс:
<ul>
    <li>Дополнение возможностей функциональных кнопок таких, как <em>Enter</em>, <em>Shift</em>, <em>Tab</em> и т.д. Пример реализации:<br> <pre>
      new KeyNav&lt;ComponentEvent&gt;((MainViewImpl) MainViewImpl.instance) {
         @Override 
        public void onEnter(ComponentEvent ce) {
          // TODO: business code.
        }

         @Override
        public void onShift(ComponentEvent ce) {
          // TODO: business code.
        }
        ...
      }
    </pre> </li>
    <li>Блокирование нажатий по элементам интерфейса (кнопкам тулбара, статусбара и т.д.) для операций, требующих определенное время на выполнение своей работы. Рекомендуется использовать следующий код:<br> <pre>
      MainViewImpl.instance.mask("Your message!");
      MainViewImpl.instance.unmask();
    </pre> </li>
</ul>
<h4><a name="removeListener">Удаление слушателей событий</a></h4> Для корректного удаления слушателей событий компонент в прикладных модулях JepRia, необходимо позаботиться и об удалении нативных слушателей GXT. В противном случае, возникает повторный вызов бизнес-логики JepListener.
<br> Для примера рассмотрим случай, когда требуется переопределить стандартную логику двойного клика на списочной форме.
<br> Ниже приводится фрагмент кода презентера детальной формы, который следует использовать в данном случае:
<pre>
  ...
  public void bind() {
    super.bind();

    //удаляем внутреннего слушателя
    list.removeListener(JepEventType.ROW_DOUBLE_CLICK_EVENT, (JepListener) list.getListeners(JepEventType.ROW_DOUBLE_CLICK_EVENT).get(0));

    //а также нативный листенер
    Grid&lt;JepRecord&gt; grid = (Grid&lt;JepRecord&gt;) list.getWidget();
    grid.removeListener(Events.RowDoubleClick, grid.getListeners(Events.RowDoubleClick).get(0));

    //определяем новую бизнес-логику
    list.addListener(JepEventType.ROW_DOUBLE_CLICK_EVENT, new JepListener() {
      public void handleEvent(JepEvent event) {
        // ... your business-code
      }
    }); 
    ...
  }
  ...
</pre> В других случаях, поступаем аналогично.
<h4><a name="antZip">Использование zip-архиватора с русскими именами файлов</a></h4> Иногда возникает необходимость вернуть клиенту несколько файлов в ответ на одиночный запрос. В таком случае хорошей практикой является использование архиватора. Штатный класс
<code>java.util.zip.ZipOutputStream</code> до версии 7 умеет работать только с латинскими именами файлов. Так как код, работающий на сервере, зачастую использует более старую версию Java, для файлов, названия которых содержат кириллицу, проблема остается актуальной.
<br> Наиболее простым решением данной проблемы является использование класса
<code>org.apache.tools.zip.ZipOutputStream</code>.
<br> Для этого необходимо включить в build.xml библиотеку ant.jar:
<br>
<pre>
  ...
  &lt;path id="libs"&gt;
    ...
    &lt;pathelement location="${ANT_HOME}/lib/ant.jar"/&gt;
    ...
  &lt;/path&gt;
  ...  
  &lt;target depends="web-jar" name="war"&gt;
    &lt;outofdate&gt;
      ...
      &lt;sequential&gt;
        ...
        &lt;copy file="${ANT_HOME}/lib/ant.jar" todir="temp-war/WEB-INF/lib"/&gt;
        ...
      &lt;/sequential&gt;
    &lt;/outofdate&gt;
  &lt;/target&gt;
  ...
</pre> В приведенном ниже примере мы возвращаем клиенту архив, содержащий текстовый файл c кириллическим именем и произвольный двоичный файл (созданный заранее):
<br>
<pre>
  package com.technology.&lt;project name&gt;.&lt;application name&gt;.&lt;module name&gt;.server;

  import org.apache.tools.zip.ZipEntry;
  import org.apache.tools.zip.ZipOutputStream;
  ...

  public class ZipServlet extends HttpServlet{

  ...

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

      try {
        response.setContentType("application/zip");
        response.setHeader("Content-Disposition", "attachment;filename=download.zip");
        response.setHeader("Pragma", "public");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("Cache-Control", "cache, must-revalidate");
        response.setDateHeader("Expires", 0);
        response.setDateHeader("Last-Modified", System.currentTimeMillis());

        OutputStream outputStream = response.getOutputStream();      
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ZipOutputStream zos = new ZipOutputStream(baos);
        zos.setEncoding("Cp866");
      
        FileInputStream in = new FileInputStream(&lt;имя_файла_на_сервере&gt;);
        zos.putNextEntry(new ZipEntry("Выгрузка.bin"));
        int len;
        while ((len = in.read(buf)) &gt; 0) {
          out.write(buf, 0, len);
        }
        zos.closeEntry();
        in.close();

        zos.putNextEntry(new ZipEntry("Отчет.txt"));
        zos.write("Выгрузка завершена успешно!");
        zos.closeEntry();

        zos.flush();
        baos.flush();
        zos.close();
        baos.close();
  
        outputStream.write(baos.toByteArray());
        outputStream.flush();
        outputStream.close();
      } catch(Exception e) {
        e.printStackTrace();
      }
    }
  }
</pre>
<h4><a name="apachePoi">Работа с документами MS Office с помощью Apache POI</a></h4> Проект Apache POI позволяет средствами Java открывать, создавать и редактировать документы MS Office таких форматов как Excel, Word и PowerPoint.
<br> До версии 2003 включительно MS Office использовал двоичный формат документов (.xls, .doc), а начиная с версии 2007 для сохранения документов используется формат Open Office XML. Формат OOXML представляет собой zip-архив, содержащий текст в виде XML, графику и другие данные.
<br>
<br> Для использования POI API необходимо включить в build.xml соответствующие библиотеки:
<br>
<pre>
  ...
  &lt;path id="libs"&gt;
    ...
    &lt;pathelement location="${POI_HOME}/poi-3.9.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/poi-ooxml-3.9.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/poi-ooxml-schemas-3.9.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/poi-scratchpad-3.9.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/ooxml-lib/dom4j-1.6.1.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/ooxml-lib/stax-api-1.0.1.jar"/&gt;
    &lt;pathelement location="${POI_HOME}/ooxml-lib/xmlbeans-2.3.0.jar"/&gt;
    ...
  &lt;/path&gt;
  ...  
  &lt;target depends="web-jar" name="war"&gt;
    &lt;outofdate&gt;
      ...
      &lt;sequential&gt;
        ...
        &lt;copy file="${POI_HOME}/poi-3.9.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/poi-ooxml-3.9.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/poi-ooxml-schemas-3.9.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/poi-scratchpad-3.9.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/ooxml-lib/dom4j-1.6.1.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/ooxml-lib/stax-api-1.0.1.jar" todir="temp-war/WEB-INF/lib"/&gt;
        &lt;copy file="${POI_HOME}/ooxml-lib/xmlbeans-2.3.0.jar" todir="temp-war/WEB-INF/lib"/&gt;
        ...
      &lt;/sequential&gt;
    &lt;/outofdate&gt;
  &lt;/target&gt;
  ...
</pre> Объектная модель документов формата
<b>xls/xlsx</b> имеет следующую иерархию:
<code>Workbook &gt; Worksheet &gt; Row &gt; Column</code>
<br> Разница в работе со старым двоичным и новым форматом OOXML явно проявляется только на верхнем уровне: для работы с форматом .xls предназначен класс
<code>org.apache.poi.hssf.usermodel.HSSFWorkbook</code>, а для OOXML .xlsx 
<code>org.apache.poi.xssf.usermodel.XSSFWorkbook</code>. Ниже по иерархии прозрачно используются общие интерфейсы.
<br>
<br> Пример работы с файлом Excel  поиск и замена строки в ячейке, и сохранения в другой файл:
<pre>
  Boolean xlsxFormat = &lt;имя_исходного_файла&gt;.toLowerCase().endsWith(".xlsx");
  FileInputStream fis = new FileInputStream(&lt;имя_исходного_файла&gt;);
  Workbook workbook = xlsxFormat ? new XSSFWorkbook(fis) : new HSSFWorkbook(fis);

  Sheet sheet = workbook.getSheetAt(0);
  for (Row row : sheet) {
    for (Cell cell : row) {
      if (cell.getCellType() == Cell.CELL_TYPE_STRING) {
        String cellText = cell.getStringCellValue();
        if (cellText.contains("{FNS_ADDRESS}")) {
          cell.setCellValue("адрес ФНС");
        }
        ...
    }
  }

  FileOutputStream fos = new FileOutputStream(&lt;имя_результирующего_файла&gt;);
  workbook.write(fos);
  fos.flush();
  fos.close();
  fis.close();
</pre> Пример работы с форматом
<b>doc</b>  используется класс
<code>org.apache.poi.hwpf.usermodel.Range</code>, предоставляющий доступ к тексту всего документа (за исключением колонтитулов):
<pre>
  FileInputStream fis = new FileInputStream(&lt;имя_исходного_файла&gt;);
  HWPFDocument doc = new HWPFDocument(fis);

  Range range = doc.getRange();
  range.replaceText("{FNS_ADDRESS}","адрес ФНС");
  ...

  FileOutputStream fos = new FileOutputStream(&lt;имя_файла&gt;);
  doc.write(fos);
  fis.close();
  fos.close();
</pre> Работа с форматом
<b>docx</b> имеет следующую особенность: аналог класса
<code>Range</code> отсутствует, параграфы
<code>org.apache.poi.xwpf.usermodel.XWPFParagraph</code> в документе разбиты на более мелкие логические части
<code>org.apache.poi.xwpf.usermodel.XWPFRun</code>, и разбиение это не всегда очевидно с точки зрения пользователя.
<br> Пример разбиения параграфа (символ | означает начало следующего
<code>XWPFRun</code>):
<pre>
  {|DEP|_|NAME|} , КПП {|DEP|_|KPP|}
</pre> Возможность редактирования текста реализована в классе
<code>XWPFRun</code>, а
<code>XWPFParagraph</code> позволяет только просматривать содержимое параграфа. Таким образом, замена, например, такой фразы как
<code>{DEP_NAME}</code> в тексте становится не такой тривиальной задачей, как для формата doc.
<br> Следует заметить, что формат OOXML, к которому относится docx, позволяет вручную отредактировать xml-код документа таким образом, чтобы убрать лишнюю разбивку параграфов на
<code>XWPFRun</code>, объединив несколько элементов в один, существенно упростив дальнейшую обработку документа:
<pre>
  FileInputStream fis = new FileInputStream(&lt;имя_исходного_файла&gt;);
  XWPFDocument doc = new XWPFDocument(fis);

  for (XWPFParagraph p : doc.getParagraphs()) 
    for (XWPFRun r : p.getRuns()) 
      if (r.getText(0) != null) {
        String text = r.getText(0);
      
        text = text.replace("{FNS_ADDRESS}","адрес ФНС");
        ...
      
        r.setText(text, 0);
      }

  FileOutputStream fos = new FileOutputStream(&lt;имя_файла&gt;);
  doc.write(fos);
  fis.close();
  fos.close();
</pre> Полезные ссылки:
<ul>
    <li><a href="http://ru.wikipedia.org/wiki/Office_Open_XML" target="_blank">http://ru.wikipedia.org/wiki/Office_Open_XML</a></li>
    <li><a href="http://poi.apache.org/" target="_blank">http://poi.apache.org/</a></li>
</ul>
<h4><a name="dialogWindow">Использование модальных диалоговых окон</a></h4> Модальный диалог в GXT реализуется путем наследования класса
<code>com.extjs.gxt.ui.client.widget.Dialog</code>.
<pre>
  ...
  import com.extjs.gxt.ui.client.widget.Dialog;
  
  public class DateSelectDialog extends Dialog {

    private DateField dateField = new DateField();

    public DateSelectDialog() {
      FormLayout layout = new FormLayout();
      layout.setLabelWidth(90);
      layout.setDefaultWidth(155);
      setLayout(layout);

      setHeading("Укажите дату получения");
      setModal(true);

      setBodyBorder(true);
      setBodyStyle("padding: 8px;background: none");
      setWidth(300);
      setResizable(false);
      setClosable(false);
      setButtons(Dialog.OKCANCEL);

      okText = "Подтвердить";
      cancelText = "Отмена";

      dateField.setAllowBlank(false);
      dateField.setFieldLabel("Дата получения");
      dateField.getPropertyEditor().setFormat(DEFAULT_DATE_FORMATTER);
    
      dateField.getDatePicker().addListener(Events.Select, new Listener&lt;ComponentEvent&gt;() {
        public void handleEvent(ComponentEvent ce) {
          dateField.clearInvalid();
        }
      });

      okButton.addSelectionListener(new SelectionListener&lt;ButtonEvent&gt;() {
        public void componentSelected(ButtonEvent ce) {
          if (dateField.isValid()) {
            hide();
          }
        }
      });

      add(dateField);
    }

    public void show() {
      dateField.clear();

      super.show();
    }

    public Date getSelectedDate() {
      return dateField.getValue();
    }
  }
</pre> В конструкторе презентера (DetailFormPresenter, ListFormPresenter или FormContainerPresenter) создаем экземпляр диалогового окна и привязываем обработчик закрытия по кнопке ОК:
<br>
<pre>
  public class MyFormContainerPresenter... 
    extends JepFormContainerPresenter&lt;E, S, F&gt; implements ChangeDateEvent.DoPrintHandler {

    private DateSelectDialog dateSelectDialog;
  
    ...
  
    public MyFormContainerPresenter(JepWorkstatePlace place, F clientFactory) {
      super(place, clientFactory);

      dateSelectDialog = new DateSelectDialog();
      ...
    
      dateSelectDialog.addListener(Events.Hide, new Listener&lt;WindowEvent&gt;(){
        public void handleEvent(WindowEvent be) {
          if (Dialog.OK.equals(be.getButtonClicked().getItemId())) {
            Date selectedDate = dateSelectDialog.getSelectedDate());
            ...
          }
        }
      });
    }
    ...
  }
</pre> Пример вызова модального диалога:
<br>
<pre>
  public void onChangeDateEvent(LostEvent event) {
    lostDialog.show();
  }
</pre>
<h4><a name="browserDependentFeatures">Написание специфичного для браузера кода</a></h4> Несмотря на то, что GWT позиционируется как кроссбраузерный фреймворк, иногда возникает необходимость «затачивать» тот или иной функционал под конкретный браузер. Это связано, как правило, с различиями в обработке на уровне DOM и JavaScript. Для этих целей в GWT можно использовать механизм, именуемый
<i>поздним связыванием</i> (late binding). Идея заключается в том, что при GWT-компиляции модуля для сборки (permutation) с определёнными значениями свойств (таких как локаль либо user-agent) указанный класс подменяется другим.
<br>
<br> Рассмотрим на примере. Пусть для конкретного браузера (в нашем случае Firefox) на детальной форме вместо одного виджета (
<code>JepComboBoxField</code>) требуется отобразить другой (
<code>JepListField</code>). Для этого, во-первых, необходимо во view детальной формы создать виджет, используя метод
<code>GWT.create(Class&lt;?&gt; classLiteral)</code>. Заметим, что
<b>передаваемый методу класс должен иметь конструктор без параметров</b>. Класс
<code>JepComboBoxField</code> такого конструктора не имеет, поэтому потребуется создать его наследника с соответствующим конструктором:
<br>
<pre>
public class MyComboBoxField extends JepComboBoxField {
  public MyComboBoxField() {
    super("");
  }
}
</pre> Во view детальной формы виджет создаётся следующим кодом:
<pre>
JepMultiStateField comboBoxField = GWT.create(MyComboBoxField.class);
</pre> Во-вторых, в файле
<i>&lt;Module Name&gt;.gwt.xml</i> требуется указать:
<ol>
    <li>имя замещаемого класса (<code>com.technology.rfi.testapplication.testmodule.client.ui.widget.MyComboBoxField</code>);</li>
    <li>имя замещающего класса (<code>com.technology.jep.jepria.client.widget.field.multistate.JepListField</code>);</li>
    <li>условия, при которых осуществляется замещение.</li>
</ol>
<pre>
&lt;module rename-to="TestModule"&gt;
  . . .
  &lt;replace-with class="com.technology.jep.jepria.client.widget.field.multistate.JepListField"&gt;
    &lt;when-type-is class="com.technology.rfi.testapplication.testmodule.client.ui.widget.MyComboBoxField"/&gt;
    &lt;when-property-is name="user.agent" value="gecko1_8"/&gt;
  &lt;/replace-with&gt;
&lt;/module&gt;
</pre> Рассмотрим более сложный случай, когда замену нужно выполнять более чем для одного браузера и для конкретной (например, английской) локали. Значения user-agent в этом случае следует перечислять с помощью тега
<code>&lt;any&gt;</code>:
<pre>
&lt;replace-with class="com.technology.jep.jepria.client.widget.field.multistate.JepListField"&gt;
  &lt;when-type-is class="com.technology.rfi.testapplication.testmodule.client.ui.widget.MyComboBoxField"/&gt;
  &lt;when-property-is name="locale" value="en"/&gt;
  &lt;any&gt;
    &lt;when-property-is name="user.agent" value="gecko1_8"/&gt;
    &lt;when-property-is name="user.agent" value="safari"/&gt;
  &lt;any/&gt;
&lt;/replace-with&gt;
</pre>
<h4><a name="enterModule">Переход на произвольный модуль приложения без перезагрузки хост-страницы</a></h4> В процессе работы большого приложения со множеством модулей (форм) иногда необходим быстрый нестандартный (НЕ через модуль Navigation или закладку подчиненного модуля) переход на произвольный модуль данного приложения. При этом, очевидно, очень желательно НЕ перегружать повторно (и, в общем случае, абсолютно бесполезно) хост-страницу приложения. Для решения подобной задачи можно воспользоваться методом
<code>enterModule(&lt;MODULE_ID&gt;)</code> шины событий главного модуля. Рассмотрим простейший пример перехода на произвольный модуль:
<pre>
  // Отразим в объекте содержащем состояние приложения JepScopeStack предстоящее переключение на заданный модуль.
  
  // Подготовим новый уровень иерархии, в котором укажем на какой модуль и в каком состоянии нужно перейти.
  JepScope enterModuleScope = new JepScope(new String[] {OPERATOR_MODULE_ID}, new WorkstateEnum[] {SEARCH});
  // Очистим текущее состояние приложения.
  JepScopeStack.instance.clear();
  // Добавим новый, вновь созданный, уровень иерархии, отразив тем самым новое, желаемое нами, состояние приложения.
  JepScopeStack.instance.push(enterModuleScope);
  
  // Непосредственно переключимся на модуль (при этом в обработчиках события переключения произойдет настройка модуля 
  // в соответствии с подготовленным ранее объектом состояния приложения JepScopeStack).
  clientFactory.getMainClientFactory().getEventBus().enterModule(OPERATOR_MODULE_ID);
</pre> Использование подобного подхода позволяет практически мгновенно (для уже подгруженных модулей) переключиться на заданный модуль приложения.
<h4><a name="treeGridManager">Использование древовидной структуры на списочной форме</a></h4> Для реализации древовидной структуры на списочной форме необходимо следующим образом модифицировать прикладной код модуля:
<br>
<br>
<ol>
    <li>Начнем с <code>ListFormView:</code>
        <ol>
            <li>Установить TreeGridManager в качестве класса, управляющего списком: <pre>
  public class ReconciliationListFormViewImpl extends ListFormViewImpl&lt;TreeGridManager&gt; {
   
    public ReconciliationListFormViewImpl() {
      super(new TreeGridManager());
      ...
      </pre> </li>
            <li>В колонку, которая будут отображать элементы управления деревом, необходимо указать тип <code>TreeCell</code>. <pre>
  
  private List&lt;JepColumn&gt; getColumnConfigurations() {
    final List&lt;JepColumn&gt; columns = new ArrayList&lt;JepColumn&gt;();
    
    columns.add(new JepColumn(INCIDENT_ID, reconciliationText.reconciliation_list_incident_id(), 150, new TreeCell&lt;String&gt;()));
    ...
      </pre> </li>
        </ol> </li>
    <li>Далее модифицируем <code>ListFormPresenter:</code>
        <ol>
            <li>Необходимо инициализовать <code>TreeGridManager</code> и привязать обработчики. <pre>
   @Override
  protected void bind() {
    super.bind();
    
    treeList.bindTree();
    
    treeList.initKeys(clientFactory.getRecordDefinition());
    treeList.setLoader(new DataLoader&lt;JepRecord&gt;() {
      public void load(final Object loadConfig, final AsyncCallback&lt;List&lt;JepRecord&gt;&gt; callback) {
        service.find((PagingConfig) loadConfig, new JepAsyncCallback&lt;PagingResult&lt;JepRecord&gt;&gt;() {
          public void onSuccess(PagingResult&lt;JepRecord&gt; pagingResult) {
            List&lt;JepRecord&gt; subList = pagingResult.getData();
            callback.onSuccess(subList);
          }
        
          public void onFailure(Throwable caught) {
            callback.onFailure(caught);
            super.onFailure(caught);
          }
        });
      }
    });
  }
      </pre> </li>
        </ol> </li>
    <li>И последнее, в ejb добавить простановку значений для работы дерева: (первичный ключ, ключ родителя и флаг наличия детей) <pre>
      
  return super.find( sqlQuery,
    new ResultSetMapper&lt;JepRecord&gt;() {
      public void map(ResultSet rs, JepRecord record) throws SQLException {
        
        record.set(RECONCILIATION_ID, getInteger(rs, RECONCILIATION_ID));
        record.set(PARENT_RECONCILIATION_ID, getInteger(rs, PARENT_RECONCILIATION_ID));  
        
        boolean hasChildren = false;
        if(getInteger(rs, TreeCellNames.HAS_CHILDREN) == 1)
          hasChildren = true;
        
        record.set(TreeCellNames.HAS_CHILDREN, hasChildren);
        
        ...
          
  </pre> </li>
</ol> Пример: svn://srvbl08/RusFinanceInfo/Module/ASDManager, модули reconciliation и task
<br>
<h4><a name="sortOptions">Сортировка данных для выпадающих списков</a></h4> Для сортировки данных выпадающих списков существует несколько способов:
<ul>
    <li>на уровне базы данных (сортировка осуществляется средствами SQL)</li>
    <li>на уровне приложения:
        <ol>
            <li>в клиентской части</li>
            <li>в серверной (на уровне компонента EJB или в коде имлементации сервисного метода (в классе *ServiceImpl))</li>
        </ol> </li>
</ul> Если сортировку необходимо выполнить на уровне приложения (не в базе данных), то ее предпочтительнее осуществлять в сервисном методе. В отличие от клиентского уровня, данный подход позволит сократить время выполнения операции и при этом избежать лишней нагрузки на клиентской стороне. А в сравнении с уровнем EJB, позволит многократно использовать данные в их "первозданном" виде и возможны ситуации, когда EJB-компонент отсутствует.
<br> Ниже приведен пример реализации get-метода получения списка "Единиц измерения" с встроенной сортировкой данных в классе <a href="com/technology/jep/jepriashowcase/goods/server/service/GoodsServiceImpl.html" title="class in com.technology.jep.jepriashowcase.goods.server.service"><code>GoodsServiceImpl</code></a>:
<pre>
  <strong>import com.technology.jep.jepria.shared.util.DefaultComparator;</strong>

  public class <i>&lt;Module_Name&gt;</i>ServiceImpl extends JepDataServiceServlet implements <i>&lt;Module_Name&gt;</i>Service  {
    /**
     * Схема сравнения.
    */
    protected Comparator&lt;Object&gt; comparator;
    
    public <i>&lt;Module_Name&gt;</i>ServiceImpl() {
      ...
      <strong>this.comparator = DefaultComparator.instance;</strong>
    }
    ...

    public List&lt;JepOption&gt; getUnit() throws ApplicationException {
      List&lt;JepOption&gt; result = null;
      try {
        // Осуществляем получение данных (это может быть вызов метода EJB, извлечение из файла и прочих источников).
        result = ...
        // Сортировку осуществляем посредством компаратора
        <strong>Collections.sort(result, new Comparator
    <jepoption>
     () {
           @Override
          public int compare(JepOption o1, JepOption o2) {
            // В данном случае, отсортируем список по имени опции
            return comparator.compare(o1.getName(), o2.getName());
          }
        });
    </jepoption></strong>
      } catch (Throwable th) {
        throw new ApplicationException(th.getLocalizedMessage(), th);
      }
      return result;
    }
    ...
  }      
</pre>
<br>
<h4><a name="validation">Использование кастомных валидаторов полей или группы зависимых полей</a></h4> В случае необходимости дополнительной проверки поля/полей на системном уровне предусмотрен единый интерфейс валидации <code>Validator</code>. Для его использования следует придерживаться следующего правила:
<ul>
    <li>определение бизнес-логики проверки для группы взаимосвязанных (как минимум, двух) полей на уровне класса <code>FieldManager</code></li>
    <li>использование кастомной валидации компонента на уровне класса <code>JepMultiStateField</code></li>
</ul> Ниже приведен пример реализации валидаторов для поля даты "Дата создания запроса" и зависимых полей дат "Дата создания запроса С" и "Дата создания запроса По":
<ul>
    <li>Класс клиентских констант, определяющий идентификаторы предполагаемых валидаторов: <pre>
  <strong>import com.technology.jep.jepria.client.widget.field.validation.Validator;</strong>

  public class <i>&lt;Module_Name&gt;</i>ClientConstant extends <i>&lt;Module_Name&gt;</i>Constant {
    ...
    public final static String REQUEST_DATE_CUSTOM_VALIDATOR_ID = "REQUEST_DATE_CUSTOM_VALIDATOR_ID";
  
    public final static String BEGIN_END_DATE_CUSTOM_VALIDATOR_ID = "BEGIN_END_DATE_CUSTOM_VALIDATOR_ID";
    ...
  }      
</pre> </li>
    <li>Интерфейс представления детальной формы с возможность установки кастомного валидатора: <pre>
  <strong>import com.technology.jep.jepria.client.widget.field.validation.Validator;</strong>

  public interface <i>&lt;Module_Name&gt;</i>DetailFormView extends DetailFormView {
    ...
    <strong>void setCustomValidator(String validatorId, Validator customValidator);</strong>
    ...
  }      
</pre> </li>
    <li>Класс представления детальной формы, реализующий указанный ранее интерфейс: <pre>
  <strong>import com.technology.jep.jepria.client.widget.field.validation.Validator;</strong>

  public class <i>&lt;Module_Name&gt;</i>DetailFormViewImpl extends DetailFormViewImpl implements <i>&lt;Module_Name&gt;</i>DetailFormView {
    
    <strong>private static Validator customDatesValidator;
    private static Validator customRequestDateValidator;</strong>
    ...

    public <i>&lt;Module_Name&gt;</i>DetailFormViewImpl() {
      super(<strong>new FieldManager(){
         @Override
        public boolean isValid(){
          return super.isValid() &amp; customDatesValidator.isValid();
        }
      }</strong>);
      ...

      JepDateField requestDateDateField = new JepDateField(requestText.request_detail_request_date())<strong>{
         @Override
        public boolean isValid(){
          return super.isValid() &amp;&amp; customRequestDateValidator.isValid();
        }
      }</strong>;
    }
    <strong>
    public void setCustomValidator(String validatorId, Validator customValidator) {
      if (BEGIN_END_DATE_CUSTOM_VALIDATOR_ID.equalsIgnoreCase(validatorId)){
        RequestDetailFormViewImpl.customDatesValidator = customValidator; 
      } else if (REQUEST_DATE_CUSTOM_VALIDATOR_ID.equalsIgnoreCase(validatorId)){
        RequestDetailFormViewImpl.customRequestDateValidator = customValidator; 
      }
    }</strong>
  }      
</pre> </li>
    <li>Метод bind класс презентера детальной формы: <pre>
  <strong>import com.technology.jep.jepria.client.widget.field.validation.Validator;</strong>
  ...
  public void bind() {
    super.bind();
    ...
    // определяем кастомный валидатор взаимодействия полей начальной и конечной дат
    view.<strong>setCustomValidator</strong>(<strong>BEGIN_END_DATE_CUSTOM_VALIDATOR_ID</strong>, <strong>new Validator() {
       @Override
      public boolean isValid() {
        // Определяем бизнес-логику проверки зависимостей полей дат С и По
        ...
      }
    }</strong>);
    
    // определяем кастомный валидатор поля request_date
    view.<strong>setCustomValidator</strong>(<strong>REQUEST_DATE_CUSTOM_VALIDATOR_ID</strong>, <strong>new Validator() {
       @Override
      public boolean isValid() {
        // Определяем бизнес-логику поля "Дата создания запроса"
        ...
      }
    }</strong>);
  }
  ...      
</pre> </li>
</ul>
<br>
<h4><a name="messageBoxButton">Возможность установки обработчика событий нажатия на кнопки в наследниках MessageBox</a></h4> Для возможности установки обработчиков нажатия на кнопки в наследниках <code>MessageBox</code> на прикладном уровне необходимо использовать метод
<i>addButtonClickHandler</i>. Параметрами метода выступают обработчик нажатия на кнопку и тип переопределяемой кнопки в <code>MessageBox</code>.
<br> Рассмотрим случай, когда во время удаления требуется дополнительная проверка при удалении записи "Поставщика", если имеются связанные записи "Товаров":
<pre>
  public class <i>&lt;Module_Name&gt;</i>ListFormPresenter&lt;V extends ListFormView, E extends PlainEventBus, S extends <i>&lt;Module_Name&gt;</i>ServiceAsync, F extends StandardClientFactory&lt;E, S&gt;&gt; 
    extends ListFormPresenter&lt;V, E, S, F&gt; {
    
     @Override
    public void onDoDelete(DoDeleteEvent event) {
      if(SELECTED.equals(_workstate)) {
        final Set&lt;JepRecord&gt; records = list.getSelectionModel().getSelectedSet();
        <strong>MessageBox box</strong> = messageBox.confirmDeletion(records.size() &gt; 1, new ConfirmCallback() {
          public void onConfirm(Boolean yes) {
            ...
          }
        }
        
        <strong>box.addButtonClickHandler(<i>PredefinedButton.YES</i>, new ClickHandler() {
           @Override
          public void onClick(ClickEvent event) {
            // Ваша бизнес-логика...
          }
        });</strong>
      }
    }
  }
</pre>
<br>
<h4><a name="toolkitUpdate">Создание приложения и расширение сборщика с помощью JepRiaToolkit</a></h4> Для оптимизация процесса сборки приложений на платформе JepRia используется модуль JepRiaToolkit, расширяющий базовые возможности сборщика Ant.
<br> Все необходимые библиотеки для сборки приложения, в том числе и библиотека
<em>jepriatoolkit.jar</em>, располагаются в бинарном репозитории, путь до которого определяется переменной
<em>BIN_HOME</em> в файле
<em>local.properties</em> (в перспективе, будет использоваться одноименная переменная окружения ОС).
<br> В данной библиотеке предусмотрены такие возможности, как создание приложения "с нуля", дополнение функциональности существующего путем добавления новых модулей, возможность оптимизации процесса сборки приложения путем указания нужных форм для GWT-компиляции и прочие возможности.
<br> Однако прежде, чем воспользоваться данными возможностями, следует выполнить набор предварительных действий (если они не выполнены ранее):
<ul>
    <li>Создать директорию будущего проекта с вложенной папкой App для хранения исходных кодов и бинарных файлов прикладной части или убедиться, что такая существует</li>
    <li>Проверить наличие в данной папке таких файлов, как <em>build.xml</em>, <em>build.properties</em>, <em>dependency.properties</em>, <em>local.properties</em>. Если таковые отсутствуют, то их следует скопировать, например, из модуля JepRiaShowcase</li>
    <li>Запустить командную строку (в Windows выполнить команду cmd) и перейти в вышеуказанную App-папку проекта</li>
</ul> После этого, появляется возможность выполнения следующих действий:
<ol>
    <li> <a name="createBlankApplication">Создание «пустой» структуры приложения</a>. Для этого следует вызвать команду: <pre>ant create -DAPPLICATION_NAME=&lt;<em>CUSTOM_APPLICATION_NAME</em>&gt; -DMODULE_NAME=&lt;<em>CUSTOM_MODULE_NAME</em>&gt;</pre> В результате работы формируется файл структуры приложения &lt;<em>CUSTOM_APPLICATION_NAME</em>&gt;Definition.xml в следующем виде: <pre>
        &lt;?xml version="1.0" encoding="windows-1251"?&gt;
        &lt;application name="<em>CUSTOM_APPLICATION_NAME</em>" defaultDatasource="RFInfoDS" projectPackage="rfi"&gt;
                &lt;modules&gt;
                        &lt;module id="<em>CUSTOM_MODULE_NAME</em>" name="???" nameEn="???"&gt;
                                &lt;db package="pkg_<em>CUSTOM_APPLICATION_NAME</em>" datasource="RFInfoDS"/&gt;
                        &lt;/module&gt;
                &lt;/modules&gt;
        &lt;/application&gt;</pre> и автоматически сгенерируется по данному шаблону исходный код нового приложения <em>CUSTOM_APPLICATION_NAME</em> с модулем <em>CUSTOM_MODULE_NAME</em>. Дополнительно реализована возможность указания в качестве значения параметра <em>-DMODULE_NAME</em> списка создаваемых модулей (в таком случае, значение должно быть указано в кавычках, а соответствующие имена модулей отделяются друг от друга запятыми). </li>
    <li> <a name="appendBlankModule">Добавление «пустого» модуля к имеющейся структуре приложения</a>. Для выполнения данной задачи важно наличие готового файла структуры. В случае его отсутствия, получение его возможно способом указанным ранее либо используя команду: <pre>ant create-xml</pre> которая создаст необходимый файл, основываясь на исходном коде текущего приложения.<br> После этого можно выполнить команду: <pre>ant add -DMODULE_NAME=&lt;<em>CUSTOM_MODULE_NAME</em>&gt; -DPARENT_MODULE_NAME=&lt;<em>CUSTOM_PARENT_MODULE_NAME</em>&gt;</pre> В данном случае, указывая параметр <em>–DPARENT_MODULE_NAME</em>, определяется родительский узел, к которому будет произведено добавление нового модуля (данный параметр опционален). Если параметр не указан, то добавление будет осуществляться к корню структуры. Следует также обратить внимание, чтобы добавляемый модуль не существовал в текущем файле структуры приложения, а в случае указания родительского – также присутствовал и он.<br> Аналогично предыдущей задаче, в качестве значения параметра <em>-DMODULE_NAME</em> допускается указание списка добавляемых модулей (при этом, значение должно быть указано в кавычках, а соответствующие имена модулей отделяются друг от друга запятыми). </li>
    <li> <a name="partialBuildModule">Сборка только тех модулей приложения, которые необходимы для разработки в данный момент времени</a>. Для этих целей используется команда: <pre>ant only -DFORMS=&lt;<em>CUSTOM_FORMS</em>&gt;</pre> позволяющая внести изменения в текущий модуль таким образом, чтобы во время компиляции и сборки учитывались лишь те формы, которые определены параметром <em>-DFORMS</em>. Если таких форм несколько, то данное значение следует указывать в кавычках, а значения перечислять через запятую (в противном случае, сборщик Ant посчитает, что запятой отделяются команды для выполнения). </li>
</ol> В последующем, функциональность JepRiaToolkit будет постепенно расширяться, добавляя все новые и новые возможности.
<br>
<h4><a name="buildConfig">Конфигурации сборки</a></h4> Пересмотрен подход к переключению режима сборки приложения debug/production. В модуле AntTask использовалась перегенерация кода и настроек, влияющих на сборку приложения, по фиксированному шаблону. Такая реализация имеет определенные минусы – каcтомные настройки при переключении режимов не сохраняются. В новой версии JepRiaToolkit введен термин build configuration и соответствующее свойство в файла build.properties, задающее целевую конфигурацию:
<pre>
BUILD_CONFIG=debug
</pre> Команды
<strong>ant debug</strong> и
<strong>ant production</strong> больше не поддерживаются.
<br> Конфигурации находятся в папке App/config/&lt;название_конфигурации&gt;, и представляют собой копию файлов (необходимых для конфигурирования сборки) из папки src и вложенных папок соответственно, включая структуру каталогов. Например, это могут быть src/java/log4j.properties, src/java/…/main/&lt;application&gt;.gwt.xml и src/html/&lt;application&gt;.css. Количество дополнительных конфигураций, кроме обязательных
<strong>debug</strong> и
<strong>production</strong> (создаются автоматически при использовании цели
<strong>create-structure</strong>) не ограничено. Для существующих приложений, необходимо создание папок App/config/debug и App/config/production и копирование в них из исходников файлов, необходимых для конфигурирования сборки.
<br> В результате применения конигурации создается (обновляется) файл App/build.config, содержащий название последней примененной конфигурации, и список файлов, из которых она состоит. Файл должен коммититься в SVN вместе с исходниками и папкой App/config.
<br> Применение конфигурации происходит автоматически каждый раз перед сборкой приложения в рамках цели
<strong>build-config</strong>, и является копированием содержимого папки с конфигурацией поверх папки App.
<br> Есть ряд особенностей, связанных с применением конфигурации:
<ul>
    <li>При отсутствии целевой конфигурации (соответствующей папки) процесс сборки завершается с ошибкой.</li>
    <li>Поскольку копирование происходит из конфигурации в исходники, запрещено менять те файлы в исходниках, которые входят в конфигурацию, потому что при следующем применении конфигурации изменения будут потеряны. Чтобы избежать таких потерь, сверяются даты изменения, и если исходник новее чем этот же файл в текущей конфигурации – то и производится двоичное сравнение файлов, в случае расхождения – в лог выводится имя измененного файла из исходников, сборка завершается с ошибкой. Для решения проблемы нужно изменения в исходнике скопировать в соответствующий файл конфигурации, и запустить сборку.</li>
    <li>При отсутствии файла builg.config в папке App определение текущей конфигурации и проверка изменений в исходниках после применения конфигурации невозможны (см. выше), происходит просто применение целевой конфигурации.</li>
    <li>При применении конфигурации производится двоичное сравнение файлов, файлы без изменений не копируются.</li>
</ul>
<br>
<h4><a name="passwordField">Реализация поля с паролем</a></h4> Для реализации на форме поля с паролем достаточно будет переопределить метод addEditableCard в классе JepTextField следующий образом (вместо TextBox использовать PasswordTextBox):
<pre>
  JepTextField svnPasswordTextField = new JepTextField(svnSearcherText.svnSearcher_detail_svn_password()){
    /**
     * 
     */
     @Override
    protected void addEditableCard() {
      editableCard = new PasswordTextBox();
      editablePanel.add(editableCard);
    }
  };
</pre>
<br>
<h4><a name="publicPages">Использование public-страниц в приложениях, размещенных на Application-сервере OC4J</a></h4> Для случаев, когда в прикладных модулях требуется использование страниц для доступа неавторизованных пользователей (public-страниц) следует учесть важный момент в работе Сервера приложений Oracle AS.
<br> Как и в случае защищенных авторизацией страниц, данные ресурсы требуют определения в дескрипторе развертывания
<strong>web.xml</strong> с целью использования функционала управлением доступа. В противном случае, при размещении кода по определению идентификатора текущего оператора, а также прочие возможности <code>com.technology.jep.jepria.server.security.JepSecurityModule</code> окажутся неработоспособными на данных страницах после разрыва пользовательской сессии.
<br> Для демонстрации данного поведения следует представить ситуацию, когда в прикладном модуле требуется на public-странице отобразить логин или идентификатор текущего пользователя. Данные значения окажутся некорректными (и будут соответствовать пользователю Гость) для случаев первоначальной установки приложения или перезапуска инстанса OC4J.
<br> Чтобы решить данную проблему в прикладном модуле следует определить список общедоступных ресурсов приложения (наряду с защищенными ресурсами). Выделенный цветом блок в примере ниже соответствует правилу настройки общедоступных ресурсов :
<pre>
  &lt;web-app ... &gt;
    ...
    &lt;!-- Protect all resources of Application --&gt;
    &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Application entry points&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;http-method&gt;*&lt;/http-method&gt;
      &lt;/web-resource-collection&gt;
      &lt;auth-constraint&gt;
        &lt;!-- At least user has to possess one of the specified roles --&gt;
        &lt;role-name&gt;*&lt;/role-name&gt;
      &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;
    <span style="color:red;">
    &lt;!-- Specify all public pages or resources of Application --&gt;
    &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
          &lt;web-resource-name&gt;The list of public pages&lt;/web-resource-name&gt;
          &lt;url-pattern&gt;<em>yourPage1.jsp</em>&lt;/url-pattern&gt;
          ...
          &lt;url-pattern&gt;<em>yourPageN.jsp</em>&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
       &lt;!-- No auth-constraint means public access! --&gt;
     &lt;/security-constraint&gt;
     </span>
   &lt;/web-app&gt;
</pre> В таком случае, сервер приложений, анализируя списки ограничений по безопасности (
<em>security-constraint</em>), ищет наиболее точное совпадение с именем ресурса и разрешает доступ к ресурсу согласно ограничениям авторизации, указанных в блоке
<em>auth-constraint</em>.
<br> Для подобных ресурсов этот блок следует опустить, тем самым допуская доступ без авторизации. Однако следует заметить, что пользователи, прошедшие авторизацию, будут определяться корректно в системе с нужными полномочиями.
<br>
<b>Замечание</b>: OC4J имеет особенность в работе с шаблонами вида
<code>/abc/*</code>: фактически они трактуются как
<code>/abc*</code>. Это приводит к тому, что при указании в списке шаблонов незащищённых страниц шаблона
<code>&lt;url-pattern&gt;/JepRiaShowcase/*&lt;/url-pattern&gt;</code> (необходимого для того, чтобы в незащищённом модуле Custom был доступ к располагающимся в этой директории ресурсам GWT) оказываются незащищёнными также файлы JepRiaShowcase.jsp и JepRiaShowcaseEmbedded.jsp. Таким образом, на страницы
<code>http://localhost:8888/JepRiaShowcase/JepRiaShowcase.jsp?em=Supplier</code> или просто
<code>http://localhost:8888/JepRiaShowcase/?em=Supplier</code> (если файл JepRiaShowcase.jsp указан в секции
<code>&lt;welcome-file-list&gt;</code>) пользователь попадёт без запроса авторизации. Если же просто переименовать JepRiaShowcase.jsp в Showcase.jsp и зайти по ссылке
<code>http://localhost:8888/JepRiaShowcase/Showcase.jsp?em=Supplier</code>, то OC4J отработает корректно, перенаправив неавторизованного пользователя к форме аутентификации. В Tomcat данная проблема отсутствует.
<br>
<h4><a name="fullLoadingCheck">Проверка полной загрузки данных в цепочке зависимых полей</a></h4> При реализации логики сохранения, поиска и переходов между формами в прикладных модулях важно, чтобы пользовательский интерфейс перед выполнением обращения к базе данных успевал загрузить все данные в соответствующие поля детальной формы. В противном случае возникнет проблема неконсистентности данных (следует отличать от невалидности - формат данных корректен, но допускается сохранение несогласованных между собой данных). Во избежании подобных проблем следует учесть особенности асинхронного клиент-серверного взаимодействия. Очевидно, что менять данный подход на полностью последовательный является неоправданным и негативно скажется на производительности интерфейса.
<br> Следует оговориться, что предусмотреть все возможные сценарии и предоставить пути решения достаточно проблематично, но среди подходов к решению данной проблемы следует отнести: реализация счетчика ассинхронных вызовов, сохранение значений между зависимыми полями и ряд других. Ниже будет описана логика подхода, когда интерфейс проверяет ожидаемое и реальное значение поля-"инициатора" цепочки зависимости полей.
<br> На форме поиска прикладного модуля предположим следующую логику:
<br> Если пользователь вводит идентификатор поставщика, то для указанного значения происходит подгрузка наименования поставщика, которое в свою очередь помещается в одноименное поле. Предполагается, что отправка формы поиска возможна либо при не заполненном значении идентификатора поставщика или когда осуществилась полная загрузка значения, изменять которое допускается уже после загрузки (иначе оно будет просто переинициализировано значением из БД).
<br> Для решения данной проблемы предлагается следующее решение, которое рекомендуется к использованию в подобных ситуациях (в описанном выше примере, цепочка состоит всего из двух полей, в реальности может быть и большее количество зависимостей):
<ol>
    <li>Определяем начало данной цепочки, т.е. фактического инициатора зависимостей (в приведенном случае – это поле «Идентификатор поставщика»). В соответствии с типом этого поля, создаем поле класса презентера, в котором будет храниться значение текущего поля в момент полной загрузки всех зависимых полей (т.е. последнее поле в цепочке инициализирует данное значение).</li>
    <li>В классе детальной формы определяем поле валидатора и сеттера (set-метода) для возможности определения его логики в презентере детальной формы.</li>
    <li>Переопределяем метод <code>isValid()</code> того компонента, который является «началом» зависимости. В теле этого метода, в случае не прохождения проверки определенного ранее валидатора, следует явным образом вызывать событие изменения значения (это может быть LOST_FOCUS_EVENT, CHANGE_VALUE_EVENT, CHANGE_SELECTION_EVENT, etc). Чтобы не усложнять интерфейс лишними алертами, можно уведомлять пользователей вызовом сообщения через метод <code>markInvalid(errorMessage)</code>.</li>
    <li>В презентере в методе <code>bind()</code> проинциализировать валидатор объектом анонимного класса, в котором выполняется проверка соответствия значений поля класса с реальным значением в этом поле. Расхождение значений будет сигнализировать, что данные находятся в процессе загрузки. В данном случае валидатор выглядит просто: <pre>
  view.setValidator(new Validator(){
     @Override
    public boolean isValid() {
          return SEARCH.equals(_workstate) ? JepRiaUtil.equalWithNull(supplierId, 
        fields.getFieldValue(SUPPLIER_ID)) : true;
    }
  });
  </pre> </li>
    <li>В том же методе <code>bind()</code>, где определяется логика определения зависимости (в определении логики слушателя события изменения состояния поля), в самом последнем звене проинициализировать значение поля идентификатора значением из текущего поля.</li>
    <li>Не забыть сбросить этот идентификатор в методе <code>adjustToWorkstate()</code> и его значение можно инициализировать вызовом <code>fields.getFieldValue()</code>.</li>
    <li>Дополнительных генераций повторных событий делать не обязательно. Пользователь, увидев сообщение об ошибке, выполнит повторно действие после полной загрузки данных.</li>
</ol>
<br>
<h4><a name="cooperationAppWithDB">Взаимодействие App и DB при передаче в качестве параметра списка значений</a></h4> На данный момент, при реализации логики передачи списка значений из JepListField (список с множественным выбором) в DB (пример: необходимо создать пользователя и привязать его к нескольким регионам), существует два подхода. Забегая вперед, при решении данной ситуации
<strong>необходимо использовать второй подход</strong>. В случае выбора в качестве решения первого подхода, должны быть веские аргументы. Рассмотрим оба способа передать список параметров:
<ol>
    <li>Склеивать значения списка в одну строчку через разделитель, и передавать как один параметр в DB функцию. Соответственно при поиске обратный процесс аналогичный.</li>
    <li>Вызывать в Dao одну функцию (чтобы обернуть в одну транзакцию), которая вызывает n-раз db-функцию по привязке каждого значения из списка к текущей записи (где n-количество значений в списке). То есть для каждого значения из списка вызывать db-функцию, которая будет привязывать данное значение по первичному ключу (или иному параметру) к текущей записи. Соответственно при поиске потребуется функция, которая по первичному ключу записи будет возвращаться курсор со списком значений именно для этой записи.</li>
</ol> Вывод: Необходимо использовать второй подход, который является более простым и универсальным в использовании, так как снижается вероятность ошибки (превышению длины входного строкового параметра хранимой функции Oracle), получается более прозрачная форма взаимодействия за счет отсутствия лишнего "шифрования"/"дешифрования" списка.
<br> Для повышения производительности рекомендуется модифицировать данный подход: при поиске на списочную форму подтягивать только обязательные данные для списочной формы. Большие, объемные списки значений загружать уже непосредственно при переходе на детальную форму конкретной записи. Использовать "ленивую загрузку" (lazy-loading).
<br>
<h4><a name="noEscapeHtmlInGridCell">Отображение HTML без экранирования в ячейке на списочной форме.</a></h4> При реализации, когда в ячейке на списочной форме необходимо отобразить HTML
<strong>без экранирования</strong>, в прикладном приложении следует сделать следующее:
<ol>
    <li>В *ListFormViewImpl в качестве представления ячейки указать класс <code>SafeHtmlCell</code>. <pre>
      protected List&lt;JepColumn&gt; getColumnConfigurations() {
        return new ArrayList&lt;JepColumn&gt;() {{
          ...
          add(new JepColumn(REGION_NAME, userText.user_list_region_name(), 150, new SafeHtmlCell(), true));
          ...
    </pre> </li>
    <li>В *Dao, в ResultSetMapper, тип данных для данной ячейки должен быть <code>com.google.gwt.safehtml.shared.SafeHtmlString</code>. Для этого используем <code>fromTrustedString</code>: <pre>
      return super.find(sqlQuery,
        new ResultSetMapper&lt;JepRecord&gt;() {
          public void map(ResultSet rs, JepRecord record) throws SQLException {
            ...
            record.set(REGION_NAME, SafeHtmlUtils.fromTrustedString("HTML String")));
            ...
    </pre> </li>
</ol>
<h4><a name="commonJsp">Параметризация главной jsp-страницы приложения, вынесенной в системные ресурсы</a></h4> Главная jsp-страница приложений, вынесенная в системные ресурсы, имеет два специфичных параметра: имя приложения
<code>appName</code> и заголовок приложения
<code>appTitle</code>.
<br>
<br>
<i>Имя приложения</i>
<code>appName</code> определяет названия генерируемых js- и css-файлов (например,
<code>JepRiaShowcase.nocache.js</code>,
<code>JepRiaShowcase.css</code>) и контекстный путь, под которым, приложение по умолчанию разворачивается на сервере (
<code>/JepRiaShowcase</code>). Имя приложения формируется при сборке по имени главного gwt.xml-файла (например, файл
<code>JepRiaShowcase.gwt.xml</code> определяет имя приложения
<code>JepRiaShowcase</code>).
<br>
<br>
<i>Заголовок приложения</i>
<code>appTitle</code> — это строка, отображаемая в заголовке html-cтраницы (в названии вкладки браузера), а также на панели загрузки приложения.
<br>
<br> При загрузке главной jsp-страницы приложения
<code>Entry.jsp</code>, имя и заголовок определяются по контекстному пути URL запроса (
<code>http://jepria.org/<b>JepRiaShowcase</b>/?em=Feature</code>). Имя и заголовок можно параметризовать в файле
<code>web.xml</code> приложения с помощью контекстных параметров с именами
<code><b>app.name</b></code> и
<code><b>app.title</b></code>.
<ul>
    <li> Параметр <code>app.title</code> следует указывать, если приложению требуется отличный от «сборочного» заголовок. Например, если приложение со сборочным именем <code>JepRiaShowcase</code> (то есть с файлом <code>JepRiaShowcase.gwt.xml</code>) планируется озаглавить строкой «Выставка достижений», то перед сборкой в <code>web.xml</code> следует добавить фрагмент <pre>
&lt;web-app&gt;
  ...
  &lt;context-param&gt;
    &lt;param-name&gt;app.title&lt;/param-name&gt;
    &lt;param-value&gt;Выставка достижений&lt;/param-value&gt;
  &lt;/context-param&gt;
  ...
&lt;/web-app&gt;
  </pre> Это установит при обращении к приложению (а именно, к странице <code>/ROOT/Entry.jsp</code>) заголовок «Выставка достижений» (без параметризации в заголовке бы значилось «JepRiaShowcase» — по контекстному пути URL запроса). </li>
    <li> Параметр <code>app.name</code> следует указывать, если приложение развернутно под отличным от «сборочного» контекстным именем. Например, если приложение со сборочным именем <code>JepRiaShowcase</code> (то есть с файлом <code>JepRiaShowcase.gwt.xml</code>) планируется развернуть под контекстным именем <code>/ROOT</code>, то перед сборкой в <code>web.xml</code> следует добавить фрагмент <pre>
&lt;web-app&gt;
  ...
  &lt;context-param&gt;
    &lt;param-name&gt;app.name&lt;/param-name&gt;
    &lt;param-value&gt;JepRiaShowcase&lt;/param-value&gt;
  &lt;/context-param&gt;
  ...
&lt;/web-app&gt;
  </pre> Это обеспечит при обращении к приложению (а именно, к странице <code>/ROOT/Entry.jsp</code>) загрузку корректных файлов <code>/ROOT/JepRiaShowcase/JepRiaShowcase.nocache.js</code> и <code>/ROOT/css/JepRiaShowcase.css</code> (без параметризации загрузились бы, соответственно, несуществующие <code>/ROOT/ROOT/ROOT.nocache.js</code> и <code>/ROOT/css/ROOT.css</code>). <br><br> При отсутствии параметра <code>app.title</code>, указание параметра <code>app.name</code> также определяет заголовок. Таким образом, в этом примере при обращении к приложению в заголовке будет значиться «JepRiaShowcase» — по параметру <code>app.name</code>, а если не указывать даже <code>app.name</code> — то «ROOT» — по контекстному пути URL запроса. </li>
</ul>
<h4><a name="beanValidation">Валидация Java Beans</a></h4> Для валидации Java Beans в стэке JavaEE предусмотрена одноименная спецификация
<a href="https://beanvalidation.org/" target="_blank">Bean Vaildation</a>, являющаяся де-факто стандартом для механизмов валидации и контроля данных.
<br> Основная идея данной спецификации заключается в использовании таких аннотаций, как ﹫Null /﹫NotNull, ﹫Size, ﹫Past /﹫Future, ﹫Min /﹫Max и т.д., размещаемых над полями класса, для проверки заранее ожидаемым значениям, вхождения в границы диапозона, соответствия регулярным выражениям и т.д.
<br> Фреймворк GWT включает в себя реализацию этой спецификации версии 1.0.0, используя библиотеку Hibernate Validator 4.1.0.
<br> Для понимания идеи достаточно взглянуть на приведенный ниже исходный код:
<br>
<pre>
import javax.validation.constraints.*;

public class User {

    ﹫NotBlank(message = "Name cannot be null")
    private String name;

    ﹫AssertTrue
    private boolean hasWork;

    ﹫Size(min = 10, max = 500, message
            = "Description should be in range of 10 and 500 symbols")
    private String description;

    ﹫Min(value = 18, message = "Age should be greater than 18")
    ﹫Max(value = 100, message = "Age should be less than 100")
    private int age;

    ﹫NotNull
    ﹫Email(message = "Email must be valid")
    private String email;

    // setters and getters
} </pre> Полный список ограничений можно посмотреть в пакете
<a href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html" target="_blank">javax.validation.constraints</a>. Применение данной библиотеки в прикладном коде можно посмотреть на примере модуля
<a href="svn://srvbl08/RusFinanceInfo/Module/OnlineApproval/Trunk/App" target="_blank">OnlineApproval</a> или заглянуть в
<a href="http://www.gwtproject.org/doc/latest/DevGuideValidation.html" target="_blank">документацию GWT</a>.
<h3><a name="refactoringNeeded">Косвенные признаки необходимости рефакторинга</a></h3> При наличии в коде нижеописанных конструкций и методов, в большинстве случаев, необходим рефакторинг данного кода. Наличие упомянутых конструкций и методов (в большинстве случаев) свидетельствует о непонятном (
<u>в первую очередь для написавшего разработчика</u>) поведении кода. Очень часто это скрывает саму суть (источник) проблемы. Т.о. по «тяжести» последствий применение этих конструкций и методов сравнимо с сокрытием сообщений об ошибках.
<br>
<br> Конструкции, при наличии которых требуется рефакторинг:
<ol>
    <li> <pre>
      ...
      Scheduler.get().scheduleDeferred(new ScheduledCommand() {
        public void execute() {
          ...
        }
      });
      ...
    </pre> </li>
</ol> Методы, при наличии которых требуется рефакторинг:
<ol>
    <li> <pre>
      ...
      &lt;some Container&gt;.layout();
      ...
    </pre> </li>
    <li> <pre>
      ...
      &lt;some Container&gt;.layout(true);
      ...
    </pre> </li>
</ol> Многократное переключение
<code>Place</code> (даже на тот же самый) в процессе отработки события
<code>EventBus</code>.
<br> Крайне желательно, для нормальной работы
<code>History</code> (для исключения ощущения у пользователя "пробуксовки" кнопок Вперед-Назад), чтобы при отработке события
<code>EventBus</code>,
<code>Place</code> переключался НЕ более одного раза.
<h3><a name="autoTestConcept">Автоматизированное тестирование</a></h3>
<h4><a name="autoTestGeneral">Основные положения</a></h4> Существуют следующие варианты тестирования клиентской части GWT-приложений:
<ol>
    <li>Простейшее unit-тестирование с использованием исключительно JUnit (state и ограниченно interaction). Данный метод используется при тестировании компонентов, не требующих JavaScript (в MVP-архитектуре это в первую очередь презентеры).</li>
    <li>Mock-тестирование, необходимое при тестировании сложных взаимодействий. Для GWT-приложений существуют следующие варианты:
        <ul>
            <li>Классическое mock-тестирование с помощью Mockito (Существуют и другие фреймворки mock-тестирования, к примеру, EasyMock, но они не используются в проекте JEP). Подходит в ситуациях, когда тестируется код, не содержащий GWT-зависимостей, а также если не требуется модифицировать поведение private и static методов, конструкторов, final методов.</li>
            <li>Mock-тестирование с использованием PowerMock позволяет обойти перечисленные выше ограничения. Недостатком тестирования с помощью PowerMock является крайне низкая их производительность.</li>
            <li>Mock-тестирование с использованием GwtMockito. <a href="https://objectpartners.com/2013/11/07/testing-gwt-with-gwtmockito/" target="_blank">GwtMockito</a> — расширение Mockito, позволяющее обойти невозможность запуска GWT-кода вне браузера. Фактически GwtMockito работает по тому же принципу, что и PowerMock, но предназначено для обхода ограничений, накладываемых GWT.</li>
        </ul> Следует заметить, что если для тестирования презентера приходится привлекать PowerMock либо GwtMockito, то это, скорее всего, говорит о <a href="https://stackoverflow.com/a/30163045" target="_blank">необходимости его рефакторинга</a>. <b>Презентер не должен содержать прямых либо косвенных зависимостей от GWT.</b> </li>
    <li>Тестирование с использованием <code>GWTTestCase</code> необходимо для компонентов, для которых требуется JavaScript, и когда TestCase может быть не слишком сложно/дорого воспроизведён. Основной недостаток <code>GWTTestCase</code> — необходимость в GWT-компиляции и, как следствие, низкая производительность.</li>
    <li>Тестирование с использованием Selenium (и ему подобных продуктов). Требуется, когда TestCase слишком сложно воспроизвести иными способами, чем повторить всю последовательность действий пользователя. Также используется для интеграционного тестирования. Руководство по написанию Selenium-тестов находится в файле <code>Doc/Конфигурирование и запуск Selenium-тестов JepRia-приложений.docx</code>.</li>
</ol> Написание тестов (как и обычного кода), крайне желательно, реализовывать по принципу bottom-up (от простого/элементарного к сложному/комплексному) - чтобы на любой момент времени у нас был рабочий код/тест.
<br>
<h4><a name="autoTestTargets">Ant-цели для запуска тестов</a></h4> Для запуска тестов используется цель
<code>test</code>. Она последовательно запускает следующие цели:
<ul>
    <li><code>test-unit</code> — unit-тесты с использованием JUnit и Mockito, а также, возможно, GwtMockito или PowerMock (лежат в директории <code>App/test/test-unit</code>);</li>
    <li><code>test-dao</code> — тесты Dao (лежат в директории <code>App/test</code>, планируется перенос в <code>App/test/test-dao</code>);</li>
    <li><code>test-services</code> — тесты сервисов (лежат в директории <code>App/test</code>, планируется перенос в <code>App/test/test-services</code>);</li>
    <li><code>test-by-selenium</code> — тесты с помощью Selenium (лежат в директории <code>App/test</code>, планируется перенос в <code>App/test/test-selenium</code>);</li>
    <li><code>test-gwt</code> — тесты с использованием GWTTestCase (лежат в директории <code>App/test-gwt</code>, планируется перенос в <code>App/test/test-gwt</code>).</li>
</ul> Для получения документации по тестированию необходимо сгенерировать документацию целью
<code>ant doc-with-test</code>.
<br>
<h4><a name="autoTestGwtTestCase">Особенности использования GWTTestCase</a></h4>
<ul>
    <li>Необходимо наличие библиотеки <code>xercesImpl.jar</code> в директории JDK <code>jre/lib/ext</code></li>
    <li>Если необходимо тестировать ближе к реальной работе приложения, то необходимо использовать тест уже на уровне JavaScript.<br> Для включения этого режима (так называемый режим <code>«production»</code> в терминах GWTTestCase) необходимо использовать опцию <code>«-prod»</code> при запуске GWTTestCase (смотри <code>build.xml</code>).<br> <b>Внимание:</b> некоторый функционал связанный с отрисовкой (render'ом) может просто НЕ работать (выдавать ошибку) при работе НЕ на уровне JavaScript.</li>
    <li>В GWT 2.8.0 для автоматизированного тестирования используется сервер приложений Jetty 9.2.14. Источник: <a href="https://gwt.googlesource.com/gwt/+/2.8.0/dev/build.xml" target="_blank">https://gwt.googlesource.com/gwt/+/2.8.0/dev/build.xml</a><br> Особенностью Jetty является тот факт, что меппинг сервлетов Jetty берет <u>НЕ</u> из <code>web.xml</code> (как обычно из тегов <code>&lt;servlet&gt;</code>), а из <code>*.gwt.xml</code>-файлов.<br> Пример из <code>JepRiaShowcase.gwt.xml</code>: <pre>
  &lt;servlet path="/MainService" class="com.technology.jep.jepria.server.service.JepMainServiceServletTest" /&gt;
    </pre> </li>
    <li><code>GWTTestCase</code>'ом тестируется, главным образом, клиентская часть. Приложение в режиме теста «ограничивается» на уровне сервисов. Т.е. при тесте данные, получаемые сервисом из <code>Dao</code> и базы данных, подменяются тестовыми данными, сформированными самим разработчиком. При этом, тестовый код сервисов размещается в директории тестовых исходных кодов <code>App/test-gwt</code> в соответствующем тестируемому классу пакете с добавлением к имени класса постфикса <code>*Test</code>.<br> Реализацию подобного подхода можно посмотреть на примере класса <code>com.technology.jep.jepria.server.service.JepMainServiceServletTest</code>. </li>
</ul> Полезная информация:
<ul>
    <li><a href="http://www.gwtproject.org/doc/latest/DevGuideTesting.html" target="_blank">http://www.gwtproject.org/doc/latest/DevGuideTesting.html</a></li>
    <li><a href="http://junit.sourceforge.net/javadoc/org/junit/Assert.html" target="_blank">http://junit.sourceforge.net/javadoc/org/junit/Assert.html</a></li>
    <li>Составные части Jetty (включая исходники) можно найти здесь: <a href="http://central.maven.org/maven2/org/mortbay/jetty/" target="_blank">http://central.maven.org/maven2/org/mortbay/jetty/</a></li>
</ul>
<h3><a name="cssAgreement">Соглашение по использованию стилей css</a></h3> Для унификации внешнего вида приложений, виджетов (в случае системных модулей) используются css-файлы стилей.
<br> В обычном JepRia-приложении используются два файла стилей (смотри пример в
<code>JepRiaShowcase.jsp</code>):
<ul>
    <li><code>JepRia.css</code> - копируется автоматически ant'ом при сборке приложения из модуля <code>JepRia</code></li>
    <li><code>&lt;Module Name&gt;.css</code> - стили специфичные для конкретного приложения</li>
</ul> В большинстве приложений файл
<code>&lt;Module Name&gt;.css</code> пустой. Однако, он обязательно должен быть для корректной сборки приложения.
<br>
<br> Для
<a href="http://vvz.nw.ru/Lessons/CSS/selectors.htm" target="_blank">селекторов</a> (классов стилей) приняты следующие соглашения по наименованию:
<ul>
    <li>.&lt;мoduleName&gt;-КлассЭлемента-свойство-свойство-....<br> Примеры:
        <ul>
            <li>Модуль <code>JepRia</code>, файл <code>JepRia.css:</code> <pre>
  .jepRia-ToggleButton-down-hovering {
    margin-right: 4px;
    margin-bottom: 4px;
    padding: 0px 0px 0px 1px;
    border-width: 1px;
  }
  .jepRia-RichTextToolbar .jepRia-ToggleButton-up-hovering {
    margin-right: 4px;
    margin-bottom: 4px;
    padding: 0px 1px 0px 0px;
    border-width: 1px;
  }
        </pre> </li>
            <li>Модуль <code>JepRiaShowcase</code>, файл <code>JepRiaShowcase.css:</code> <pre>
  .jepRiaShowcase-ShowcaseToggleButton-down-hovering {
    margin-right: 4px;
    margin-bottom: 4px;
    padding: 0px 0px 0px 1px;
    border-width: 1px;
  }
  .jepRiaShowcase-ShowcaseRichTextToolbar .jepRiaShowcase-ShowcaseToggleButton-up-hovering {
    margin-right: 4px;
    margin-bottom: 4px;
    padding: 0px 1px 0px 0px;
    border-width: 1px;
  }
        </pre> </li>
        </ul> </li>
</ul> В коде стили указываются либо в константах модуля (общеупотребимые стили), либо в константах конкретного класса (стили специфичные для класса). Т.о., применение стилей происходит, например, так:
<br>
<pre>
  someWidget.addStyleName(&lt;КОНСТАНТА МОДУЛЯ&gt; или &lt;КОНСТАНТА КЛАССА&gt;);
  ...
  someElement.addClassName(&lt;КОНСТАНТА МОДУЛЯ&gt; или &lt;КОНСТАНТА КЛАССА&gt;);
</pre> При верстке обычного html-кода (например, для модулей с произвольным расположением виджетов по верстке), в
<a href="http://vvz.nw.ru/Lessons/CSS/selectors.htm" target="_blank">селекторах</a> стилей удобно указывать html-элементы, к которым данный стиль применяется:
<br>
<pre>
/* Заголовки */
h1.someModule, h2.someModule, h3.someModule, h4.someModule {
  text-align: left;
  font-weight: bold;
  font-family: Verdana, Geneva, sans-serif;
  color: black;
}

h1.someModule.center, h2.someModule.center, h3.someModule.center, h4.someModule.center {
  text-align: center;
}
h1.someModule.right, h2.someModule.right, h3.someModule.right, h4.someModule.right {
  text-align: right;
}

/* Границы */
.someModule.border { 
  border: 1px solid;
}
.someModule.border-top { 
  border-top: 1px solid;
}
.someModule.border-right { 
  border-right: 1px solid;
}
.someModule.border-bottom { 
  border-bottom: 1px solid;
}
.someModule.border-left { 
  border-left: 1px solid;
}

.someModule.border-colorBlack { 
  border-color: black;
}
.someModule.border-color1 { 
  border-color: #2E8B57;
}
.someModule.border-color2 { 
  border-color: #FF4D00;
}
.someModule.border-color3 { 
  border-color: #8B00FF;
}

/* Таблицы */
table.someModule { 
  table-layout: auto;
  border-collapse: collapse;
  border: none;
  color: black;
  font-size: 12px;
  font-family: Verdana, Geneva, sans-serif;
}
table.someModule td { 
  text-align: left;
  vertical-align: top;
  font-weight: normal;
  padding: 1px 1px 1px 1px;
}
table.someModule th { 
  text-align: center;
  vertical-align: top;
  font-weight: bold;
  padding: 1px 1px 1px 1px;
}

table.someModule.center td {
  text-align: center;
}
table.someModule.left td {
  text-align: left;
}
table.someModule.right td {
  text-align: right;
}
table.someModule.top td {
  vertical-align: top;
}
table.someModule.middle td {
  vertical-align: middle;
}
table.someModule.bottom td {
  vertical-align: bottom;
}

table.someModule td.someModule.center {
  text-align: center;
}
table.someModule td.someModule.left {
  text-align: left;
}
table.someModule td.someModule.right {
  text-align: right;
}
table.someModule td.someModule.top {
  vertical-align: top;
}
table.someModule td.someModule.middle {
  vertical-align: middle;
}
table.someModule td.someModule.bottom {
  vertical-align: bottom;
}

/* Цвета */
.someModule.colorBlack { 
  color: black;
}
.someModule.color1 { 
  color: #2E8B57;
}
.someModule.color2 { 
  color: #FF4D00;
}
.someModule.color3 { 
  color: #8B00FF;
}

/* Заполнение */
.someModule.fill {
  width: 100%;
  height: 100%;
}
.someModule.fill-width {
  width: 100%;
}
.someModule.fill-height {
  height: 100%;
}
</pre> Html-верстка в этом случае может выглядеть следующим образом:
<pre>
&lt;h2 class="someModule"&gt;Некоторый заголовок&lt;/h2&gt;

&lt;table class="someModule fill-width center middle"&gt;
  &lt;colgroup&gt;
    &lt;col style="width: 30%;"&gt;
    &lt;col style="width: 40%;"&gt;
    &lt;col style="width: 30%;"&gt;
  &lt;/colgroup&gt;
  &lt;tr style="height: 40px;"&gt;
    &lt;td colspan="3" class="someModule border-bottom border-color1"&gt;
      Текст 1
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style="height: 10px;"&gt;
    &lt;td colspan="3"/&gt;
  &lt;/tr&gt;
  &lt;tr style="height: 100px;"&gt;
    &lt;td class="someModule border-right border-color1"&gt;
      Текст 2
    &lt;/td&gt;
    &lt;td/&gt;
    &lt;td class="someModule border-left border-color1 top"&gt;
      Текст 3
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<h3><a name="buildScenarioUpdate">Корректное обновление сценария сборки</a></h3> При обновлении сценария сборки прикладного модуля build.xml (при копировании его из актуальной версии JepRiaShowcase) единовременно нужно обновить все вспомогательные файлы:
<b>build.properties, dependency.properties, local.properties, test.properties,</b> а также обновить их в папке config (если они там присутствуют).
<br>
<br> Неполное обновление набора файлов — например, обновился build.xml, но dependency.properties остался старым — может повлечь ошибки при выполнении сценария сборки.
<br>
<br> Также важно помнить, что файлы build.config и dependency-jepria.properties являются генерируемыми, и добавлять их в репозиторий не нужно.
<h3><a name="binRepoPreparation">Подготовка бинарного репозитория</a></h3> Для возможности установки данного модуля необходимо сперва развернуть бинарный репозиторий на локальном окружении.
<br> Для этого достаточно скачать модуль
<a target="_blank" href="https://svn.code.sf.net/p/javaenterpriseplatform/svn/Bin">Bin</a> в подходящую директорию на локальной файловой системе ОС, ссылка на которую будет использована во время установки модуля.
<h3><a name="deploy">Установка</a></h3> Перед установкой необходимо убедиться в наличии бинарного репозитория на локальном окружении, с которого производится установка данного модуля:
<ul>
    <li>В случае его отсутствия необходимо выполнить действия из раздела <a href="#binRepoPreparation">Подготовка бинарного репозитория</a> и продолжить установку.</li>
    <li>Если бинарный репозиторий уже настроен, то рекомендуется произвести его актуализацию, выполнив команду SVN Update, после чего продолжить установку.</li>
</ul> Для продолжения установки текущего модуля, необходимо перейти в директорию
<i>App</i> модуля и выполнить команду:
<i>ant tomcat.deploy -DDEPLOYMENT_PATH=&lt;DEPLOYMENT_PATH&gt; -DLOGIN=&lt;LOGIN&gt; -DPASSWORD=&lt;PASSWORD&gt; -DLOAD_OPERATORID=&lt;LOAD_OPERATORID&gt;&nbsp; -DBIN_HOME=&lt;BIN_HOME&gt;&nbsp;</i>, где
<br>
<ul>
    <li>DEPLOYMENT_PATH - адрес установки модуля (Пример: <i>http[s]://host:port/manager/text</i>)</li>
    <li>PORT - параметр нужен в случае, если http-порт на сервере отличен от 80го (по-умолчанию значение 80)</li>
    <li>LOGIN - логин пользователя, под которым происходит установка модуля</li>
    <li>PASSWORD - пароль пользователя, под которым происходит установка модуля</li>
    <li>LOAD_OPERATORID - логин/пароль учетной записи в системе, от чьего имени производится установка</li>
    <li>BIN_HOME - директория бинарного репозитория</li>
</ul> Пример:
<pre>ant tomcat.deploy -DDEPLOYMENT_PATH=http://host:tomcatPort/manager/text -DLOGIN=LOGIN -DPASSWORD=PASSWORD -DLOAD_OPERATORID=user/123 -DBIN_HOME=C:/Project/JEP/Bin<br></pre> Замечание: для того, чтобы сборщик
<a href="http://ant.apache.org">Ant</a> находился без указания полного пути к нему, необходимо в переменную окружения
<i>Path</i> добавить путь к исполняемым файлам
<a href="http://ant.apache.org">Ant</a>, например:
<pre>
Path=.....D:\WINDOWS\system32;D:\WINDOWS;<i>D:\oracle\jdev101330\ant\bin</i>
</pre>
<h3><a name="testCases">Тестовые сценарии</a></h3>
<ul>
    <li>/JepRiaShowcase/App/test/java/com/technology/jep/jepriashowcase/feature/auto/FeatureAutoTestStandard.java - Реализация стандартных тестов - создание, редактирование, удаление, поиск.</li>
    <li>/JepRiaShowcase/App/test/java/com/technology/jep/jepriashowcase/feature/auto/FeatureAutoTestBusinessProcess.java - Реализация тестирования пользовательских сценариев.</li>
</ul>
<h3><a name="error">Ошибки</a></h3>
<br>
<h3><a name="todo">Доработки</a></h3>
<br>
<h3><a name="releaseNotes">Замечания к версиям</a></h3>
<h4>Версии</h4>
<ul>
    <li><a href="#11.0.0">11.0.0 (2020-01-16)</a></li>
    <li><a href="#10.10.0">10.10.0 (2018-10-16)</a></li>
    <li><a href="#10.9.0">10.9.0 (2018-05-18)</a></li>
    <li><a href="#10.8.3">10.8.3 (2018-03-22)</a></li>
    <li><a href="#10.8.2">10.8.2 (2018-02-16)</a></li>
    <li><a href="#10.6.2">10.6.2 (2018-01-31)</a></li>
    <li><a href="#10.6.1">10.6.1 (2018-01-23)</a></li>
    <li><a href="#10.6.0">10.6.0 (2018-01-10)</a></li>
    <li><a href="#10.5.0">10.5.0 (2017-10-20)</a></li>
    <li><a href="#10.4.0">10.4.0 (2017-10-18)</a></li>
    <li><a href="#10.3.1">10.3.1 (2017-10-13)</a></li>
    <li><a href="#10.3.0">10.3.0 (2017-10-02)</a></li>
    <li><a href="#10.2.5">10.2.5 (2017-08-10)</a></li>
    <li><a href="#10.0.0">10.0.0 (2017-04-05)</a></li>
    <li><a href="#9.9.0">9.9.0 (2017-03-21)</a></li>
    <li><a href="#9.8.0">9.8.0 (2017-03-16)</a></li>
    <li><a href="#9.6.0">9.6.0 (2017-02-06)</a></li>
    <li><a href="#9.5.0">9.5.0 (2017-02-02)</a></li>
    <li><a href="#9.4.0">9.4.0 (2016-12-22)</a></li>
    <li><a href="#9.3.0">9.3.0 (2016-11-24)</a></li>
    <li><a href="#9.2.0">9.2.0 (2016-11-09)</a></li>
    <li><a href="#9.1.0">9.1.0 (2016-09-29)</a></li>
    <li><a href="#9.0.0">9.0.0 (2016-04-12)</a></li>
    <li><a href="#8.9.2">8.9.2 (2016-02-02)</a></li>
    <li><a href="#8.9.1">8.9.1 (2016-01-26)</a></li>
    <li><a href="#8.9.0">8.9.0 (2016-01-26)</a></li>
    <li><a href="#8.8.0">8.8.0 (2015-11-24)</a></li>
    <li><a href="#8.0.0">8.0.0 (2014-05-14)</a></li>
</ul>
<h5><a name="11.0.0">11.0.0 (2020-01-16)</a></h5>
<ul>
   <li><b>[+]:</b> REST API на Jaxrs/Jersey, Gson</li>
   <li><b>[+]:</b> Компонентная структура</li>
</ul> 
<h5><a name="10.10.0">10.10.0 (2018-10-16)</a></h5>
<ul>
    <li>[!] исправлены тесты (на данный момент два теста невалидны FeatureServiceTest, FeatureDaoTest)</li>
    <li>[*] Сборка на обновленной JepRia-10.10.0-SNAPSHOT</li>
    <li>[+] Добавлен функ-л по обработке событий на мобильных платформах для полей с маской, в частности JepDateField</li>
    <li>[+] Исправление в JepMoneyField при форматировании числа</li>
    <li>[*] Обновлен ф-л поля JepMoneyField и JepDateField</li>
    <li>[-] убрано ненужное дублирование web.xml в config</li>
    <li>[*] Обновлен ф-л поля JepMoneyField</li>
    <li>[*] build xml: do-sign: buildUUID выводится в ant логе</li>
    <li>[*] Форматирование числа при прогрмааной установке значения</li>
    <li>[*] Проверка функционала с вводом даты и времени в JepDateField</li>
    <li>[+] "подпись приложения" больше не использует внешний JS (внедрено в Entry.jsp)</li>
    <li>[!] Откат изменений, связанных с использованием Weld (применение DI)</li>
    <li>[*] Правка от Романа Телкова: переименование setNavigationPanelOfCalendar -> setNavigationPanel</li>
    <li>[+] Добавлена документация по BeanValidation</li>
    <li>[+] исправлено подключение класса для генерации "подписи" приложения</li>
    <li>[+] добавлен новый функционал генерации JSON с информацией о сборке (доступно по URL ./actuator/version.json)</li>
</ul>
<h5><a name="10.9.0">10.9.0 (2018-05-18)</a></h5>
<ul>
    <li><b>[+]:</b> теперь в JSP в плашку (в debug сборке) и в html (в прод сборке) вставляется информация о deploy. Пример Deploy at: 19.04.2018 11:49:17 From: ***-***-20546-1 SVN: 54743:54744M, Trunk JepRIA: 10.6.0, Size: 11Mb</li>
    <li><b>[*]:</b> Исправления для работы с новой реализацией expand/collapse в JepTreeField</li>
</ul>
<h5><a name="10.8.3">Версия 10.8.3 (2018-03-22)</a></h5>
<h5><a name="10.8.2">Версия 10.8.2 (2018-02-16)</a></h5>
<ul>
    <li>[*] Цель IncludeSystemDependency переименована в IncludeDependencyPackage</li>
    <li>[*] IncludeDependencyPackage и BuildConfigSwitcher вызываются статически при инициализации сборки (fix невозможности переопределить CONTEXT_PATH в deploy.properties)</li>
    <li>[*] Кастомные JSP-страницы приведены к виду Entry.jsp</li>
</ul>
<h5><a name="10.6.2">Версия 10.6.2 (2018-01-31)</a></h5>
<ul>
    <li>[*] Примеры использования UIBinding:
        <ul>
            <li>Знаки табуляции заменены на пробелы.</li>
            <li></li>
            <li>Форматирование значения поля во время ввода, чтобы можно было различать разряды числа.</li>
            <li>Изменено название временной директории в соответствии с названиями ранее созданных временных директорий (изменено с mytmp на temp-gwt-compile).</li>
            <li>Скорректировано отображения иконки загрузки и ошибки комбобокса в chrome</li>
        </ul> </li>
    <li>[*] Главная jsp-страница приложения вынесена в системные ресурсы, с возможностью указания заголовка и имени приложения на прикладном уровне (в <code>web.xml</code>)</li>
</ul>
<h5><a name="10.6.1">Версия 10.6.1 (2018-01-23)</a></h5>
<ul>
    <li>[*] Примеры использования UIBinding:
        <ul>
            <li>Переопределение поля JepTextField в JepFieldCustomerUiBinder.ui.xml</li>
            <li>Ориентация виджетов на панели (вертикальная, горизонтальная)</li>
        </ul> </li>
    <li>[*] Главная jsp-страница приложения вынесена в системные ресурсы, с возможностью указания заголовка и имени приложения на прикладном уровне (в <code>web.xml</code>)</li>
</ul>
<h5><a name="10.6.0">Версия 10.6.0 (2018-01-10)</a></h5>
<ul>
    <li>[*] build.xml : цель check-dependencies разделена на check-build-dependencies, check-deploy-dependencies.</li>
    <li>[*] dependency.properties актуализированы в соответствии с изменениями бинарного репозитория.</li>
    <li>[*] Рефакторинг под последнии изменения системной части JepRia 10.6.0:
        <ol>
            <li>Переименование RefreshEvent в RefreshListEvent.</li>
            <li>Изменения в ClientSecurity.</li>
        </ol> </li>
</ul>
<h5><a name="10.5.0">Версия 10.5.0 (2017-10-20)</a></h5>
<ul>
    <li>[*] Сборка на версии JepRia 10.4.0, без изменений в приложении.</li>
</ul>
<h5><a name="10.4.0">Версия 10.4.0 (2017-10-18)</a></h5>
<ul>
    <li>[*] Сборка на версиях: JepRia 10.3.1, JepRiaToolkit 7.11.0, без изменений в приложении.</li>
</ul>
<h5><a name="10.3.1">Версия 10.3.1 (2017-10-13)</a></h5>
<ul>
    <li>[*] Сборка на версии JepRia 10.3.1, без изменений в приложении.</li>
</ul>
<h5><a name="10.3.0">Версия 10.3.0 (2017-10-02)</a></h5>
<ul>
    <li>[*] Изменения в процессе сборки приложения:
        <ul>
            <li>[*] Многократно уменьшена скорость Debug сборки</li>
            <li>[*] Временные файлы GWT-компиляции размещаются во временной подпапке приложения и удаляются после сборки</li>
        </ul> </li>
    <li>[*] Изменения в клиентской архитектуре:
        <ul>
            <li>[-] Убраны вызовы <code>initActivityMappers</code></li>
            <li>[*] Релизация <code>JepRiaShowcaseMainViewImpl</code></li>
        </ul> </li>
    <li>[!] fix: Исправлен механизм загрузки файлов с помощью зависимой библиотеки.</li>
</ul>
<h5><a name="10.2.5">Версия 10.2.5 (2017-08-10)</a></h5>
<ul>
    <li>[*] Зависимости, необходимые только для JepRia, копируются из системной библиотеки jepria-dependency.jar (since Jepria-10.2.3).</li>
</ul>
<h5><a name="10.0.0">Версия 10.0.0 (2017-04-05)</a></h5>
<ul>
    <li>[*] Изменения в структуре приложения и процессе его сборки:
        <ul>
            <li>[*] В production-сборке принудительно пересобирается автодокументация.</li>
            <li>[*] Удалены зависимости от OC4J и WebLogic.</li>
            <li>[*] Удалены более не актуальные конфигурационные файлы application.xml, orion-application.xml, context.xml.</li>
            <li>[*] Переход на JepRia 10.0.0, GWT 2.8.0, Java 8.</li>
            <li>[*] Разные мелкие улучшения.</li>
        </ul> </li>
    <li>[+] Добавлен тест раскрытия узла в JepTreeField.</li>
    <li>[!] В текстовых ресурсах изменена кодировка на UTF-8 без BOM (где требовалось).</li>
    <li>[*] Вызовы <code>DaoSupport.execute(String, Class, Object...)</code> заменены на <code>DaoSupport.executeAndReturn()</code> (в соответствии с изменениями в JepRia).</li>
    <li>[!] В модуле "Поставщик" восстановлен функционал редактирования.</li>
</ul>
<h5><a name="9.9.0">Версия 9.9.0 (2017-03-21)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.7.0.</li>
</ul>
<h5><a name="9.8.0">Версия 9.8.0 (2017-03-16)</a></h5>
<ul>
    <li>[*] Переход на JepRiaToolkit 7.4.0.</li>
    <li>[*] build.xml: поддержка сохранения версионности установок на Tomcat.</li>
    <li>[*] Актуализация *.jsp: поддержка i18n ресурсов, параметризован класс контейнера Test Build Message.</li>
</ul>
<h5><a name="9.6.0">Версия 9.6.0 (2017-02-06)</a></h5>
<ul>
    <li>[*] Переход на JepRiaToolkit 7.3.0.</li>
    <li>[!] Удалены css-файлы из config (Feature 1761). В JepRiaShowcase.jsp параметризован класс у блока Test Build Message.</li>
    <li>[*] Обновлена документация об установке (Feature 1601).</li>
    <li>Изменения в build.xml:
        <ul>
            <li>[*] Убрана абстрактная цель deploy. Цели *.deploy идентифицированы с веб-сервером, на который устанавливаются (Feature 1601).</li>
            <li>[*] Включена цель save-version-application для deploy.oc4j.</li>
            <li>[*] Добавлена цель test-build-message-check (скрывает Test Build Message, если сборка - production).</li>
        </ul> </li>
</ul>
<h5><a name="9.5.0">Версия 9.5.0 (2017-02-02)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.5.0.</li>
    <li>[*] Реализована загрузка i18n-ресурсов в jsp.</li>
    <li>[*] Добавлена корректная обработка ошибки 403.</li>
    <li>Изменения в Selenium-тестировании:
        <ul>
            <li>[*] Добавлена цель create-auto-test-structure</li>
            <li>[*] Рефакторинг стандартных тестов модуля Feature.</li>
        </ul> </li>
    <li>[*] Обновлена документация по установке на Tomcat.</li>
</ul>
<h5><a name="9.4.0">Версия 9.4.0 (2016-12-22)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.4.0 (в том числе актуализация тестов).</li>
    <li>[*] Поддержка авторизации через модуль Sso.</li>
    <li>Изменения в build.xml:
        <ul>
            <li>[*] Добавлен игнор частой ошибки "Unable to remove temp-war/WEB-INF/lib"</li>
            <li>[*] Драйвер ojdbc убран из прикладного модуля.</li>
        </ul> </li>
    <li>[+] В типовые решения добавлен раздел "Проблема AJAX-запросов в GWT при использовании RequestBuilder".</li>
    <li>[*] FeatureTest: В стандартных тестах логин делается один раз, а не между каждыми методами.</li>
</ul>
<h5><a name="9.3.0">Версия 9.3.0 (2016-11-24)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.3.0</li>
    <li>[*] Поддержка работы с Oracle 12</li>
    <li>[!] Исправлен баг с проверкой поля RESPONSIBLE_ID (Feature: 821).</li>
    <li>[!] Рефакторинг тестов под поддержку кастомных групп в JepRia. Актуализация кода под изменения системной библиотеки.</li>
    <li>[*] Поправлены все клиентские фабрики с заданием moduleId.</li>
    <li>[*] Удален *.bat устанавливающий кодовую страницу для консоли (см. <a href="#cmd">Решение проблемы некорректного отображения русских символов при запуске команд Ant.</a>).</li>
</ul>
<h5><a name="9.2.0">Версия 9.2.0 (2016-11-09)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.2.0</li>
    <li>[+] Реализация версии 9.2.0 модуля Feature в соответсвии с ТЗ "Запрос функционала" (Редактирование только своих фич, Возможность назначать ответственного за фичу). </li>
    <li>[+] Добавлен модуль "Статус" (FeatureProcess). Является дочерним к Feature, и предоставляет функционал управления статусами для фич.</li>
    <li>[+] Добавлен модуль "Пользователь запросов" (FeatureOperator). Предоставляет функционал управления пользователя фич.</li>
    <li>[+] Переработка существующих автотестов под новую системную часть автотестов JepRia.</li>
    <li>[+] Добавлены автотесты с помощью Selenium, реализующие реальные сценарии по работе с модулями Feature, FeatureStatus и FeatureOperator.</li>
    <li>Изменения в документации:
        <ul>
            <li>[+] Добавлен раздел "Кросс-доменный обмен сообщениями между веб-приложениями".</li>
            <li>[+] Типовое решение "Взаимодействие App и DB при передаче в качестве параметра списка значений".</li>
            <li>[+] Типовое решение "Решение проблемы некорректного отображения русских символов при запуске команд Ant".</li>
            <li>[+] Типовое решение "Отображение HTML без экранирования в ячейке на списочной форме".</li>
        </ul> </li>
    <li>[+] Изменения процесса сборки: в build.xml добавлена цель war-and-deploy для сборки war-файла и установки на Tomcat "в одно действие".</li>
</ul>
<h5><a name="9.1.0">Версия 9.1.0 (2016-09-29)</a></h5>
<ul>
    <li>[*] Переход на JepRia 9.1.0, JepRiaToolkit 7.1.0.</li>
    <li>[+] Для демонстрации тестирования Jep-полей с помощью Selenium создан модуль Arsenic.</li>
    <li>[+] С помощью TDD создан модуль Feature.</li>
    <li>[+] Добавлены Selenium-тесты модулей, тесты Dao и сервисов.</li>
    <li>[+] Добавлен нагрузочный тест с помощью JMeter.</li>
    <li>Изменения процесса сборки:
        <ul>
            <li>[!] Исправлена проблема из JepRiaShowcase 9.0.0: в jepriashowcase-web.jar не попадали .properties-файлы.</li>
            <li>[*] Сборка осуществляется на бинарном репозитории.</li>
            <li>[*] Прекращено копирование в /lib файла jepriatoolkit.jar.</li>
        </ul> </li>
    <li>[+] Поддержка сборки war-файла и деплоя на Tomcat.</li>
    <li>[+] В модуле Custom добавлена функция перехода по внешней ссылке.</li>
    <li>[*] Вместо табуляции для отступов используется два пробела.</li>
    <li>[*] В модуле Supplier устранена зависимость от внешнего справочника банков.</li>
    <li>[*] В web.xml и разделе "Использование public-страниц в приложениях, размещенных на Application-сервере OC4J" отражена особенность работы OC4 с шаблонами URL в секции <code>&lt;security-constraint&gt;</code>.</li>
</ul>
<h5><a name="9.0.0">Версия 9.0.0 (2016-04-12)</a></h5>
<ul>
    <li><b>chore:</b> Переход на JepRia 9.0.0, JepRiaToolkit 7.0.0.</li>
    <li><b>refactor:</b> Полный отказ от EJB:
        <ul>
            <li>EJB более не используется при взаимодействии с DB, в том числе в процессе загрузки и выгрузки файлов.</li>
            <li>Упоминания EJB исключены из application.xml, orion-application.xml, web.xml.</li>
            <li>Из процесса сборки исключены библиотеки jepria-ejb.jar и ejb30.jar.</li>
        </ul> </li>
    <li><b>chore:</b> Изменения в процессе сборки:
        <ul>
            <li>упразднён файл jepriashowcase-common.jar;</li>
            <li>изменены параметры вызова тасков applicationstructurecreator, productionbuildchecker;</li>
            <li>JepApplication.xml переименован в JepRiaShowcaseDefinition.xml;</li>
            <li>прекращено использование JepGxt;</li>
            <li>"старая"цель <code>war</code> переименована в <code>web-module</code>.</li>
        </ul> </li>
    <li><b>chore:</b> В конфигурации <code>debug</code> отключены локали.</li>
    <li><b>chore:</b> Отказ от использования CAS SSO.</li>
    <li><b>feat:</b> Поддержка SSO WebLogic.</li>
    <li><b>feat:</b> Поддержка сборки приложения в виде war-файла (новая цель <code>war</code>) и установки его на Tomcat.</li>
    <li><b>chore:</b> Из web.xml удалена конфигурация бина и сервлета версионности.</li>
    <li><b>refactor:</b> Имя текстовых ресурсов удалено из серверного кода в соответствии с изменениями в JepRia.</li>
    <li><b>feat:</b> В модуле Supplier добавлен "синтетический" пример невозможности отправки формы поиска до полной загрузки зависимых полей.</li>
    <li><b>feat:</b> В модуле Custom добавлен пример кастомных обработчиков начала и завершения транзакции.</li>
    <li><b>refactor:</b> Везде, где возможно, списочные формы модулей наследуют <code>StandardListFormViewImpl</code></li>
    <li><b>docs:</b> В <a href="#standardSolutions">Типовые решения</a> добавлен раздел <a href="#fullLoadingCheck">Проверка полной загрузки данных в цепочке зависимых полей</a>.</li>
</ul>
<h5><a name="8.9.2">Версия 8.9.2 (2016-02-02)</a></h5>
<ul>
    <li><b>feat:</b> Имя data source изменено на ITMDS.</li>
    <li><b>chore:</b> Перевод на JepRia 8.9.2.</li>
</ul>
<h5><a name="8.9.1">Версия 8.9.1 (2016-01-26)</a></h5>
<ul>
    <li><b>chore:</b> Пересборка с JepRia 8.9.1.</li>
</ul>
<h5><a name="8.9.0">Версия 8.9.0 (2016-01-26)</a></h5>
<ul>
    <li><b>feat:</b> Доработка поддержки WebLogic и CAS:
        <ul>
            <li>Вместо weblogic.jar при установке на WebLogic используется генерируемый файл wlfullclient.jar.</li>
            <li>Устранены проблемы с установкой на удалённый сервер.</li>
            <li>Упразднена переменная DEPLOY_TO_WEBLOGIC: признаком установки на WebLogic является наличие WL_DEPLOY_TARGETS.</li>
            <li>build.xml изменён для обеспечения регистрации установки на WebLogic.</li>
            <li>В JepRiaShowcaseCustom.jsp удалёны static import, поскольку они не работают в WebLogic.</li>
        </ul> </li>
    <li><b>feat:</b> В модуле Custom реализован пример управления транзакциями без использования EJB (на основе подхода AOP).</li>
    <li><b>feat:</b> Заменены конструкторы JepGrid на списочной форме.</li>
    <li><b>feat:</b> Мелкие изменения, обусловленные развитием JepRia.</li>
    <li><b>fix:</b> Устранение зависимостей от контекстной части URL приложения в web.xml.</li>
    <li><b>docs:</b> В "Типовые решения" добавлен раздел "Использование public-страниц в приложениях, размещенных на Application-сервере OC4J".</li>
    <li><b>chore:</b> Актуализация конфигураций сборки, build.xml, build.properties.</li>
</ul>
<h5><a name="8.8.0">Версия 8.8.0 (2015-11-24)</a></h5>
<ul>
    <li><b>feat:</b> На списочной форме модуля "Поставщик" добавлен столбец "Привилегированный поставщик".</li>
    <li><b>feat:</b> Актуализация в связи с изменениями в JepGrid.</li>
    <li><b>chore:</b> Из ContextRoot удалён префикс info/.</li>
    <li><b>chore:</b> Наведён порядок в процессе сборки.</li>
</ul>
<h5><a name="8.0.0">Версия 8.0.0 (2014-05-14)</a></h5>
<ul>
    <li>[+] </li>
    <li>Для перехода на версию JepRia 8.0.0 с версии JepRia 7.X.X необходимо:
        <ul>
            <li>Использовать для сборки обновленный build.xml.</li>
            <li>Использовать обновленные версии библиотек Gwt, Gwt-Log (внести соответствующие изменения в build.properties).<br> При этом необходимо сделать переименование файлов в соответствии с соглашением (убрать номера версий из названий): gwt-log-3.2.1.jar -&gt; gwt-log.jar.</li>
            <li>Существенно изменилась хост-страница: изменен тип документа на <code>&lt;!DOCTYPE html&gt;</code>, индикаторы загрузки перенесены в начало тега <code>&lt;body/&gt;</code>, на хост-странице приложения необходимо использовать константу <code>JepRiaClientConstant.APPLICATION_SLOT</code>, добавлен импорт таблиц стилей системной библиотеки <code>JepRia</code>, убрано использование стилей <code>css/gxt-all.css</code>, другие изменения - см. детали в JepRiaShowcase.jsp.</li>
            <li>Если используется Gwt-Log, то для полноценной настройки (и избежания соответствующего сообщения при Gwt-компиляции) необходимо добавить генерирование symbolMaps в параметры Gwt-компилятора и использование symbolMaps сервлетом Gwt-Log - см. <code>build.xml, web.xml </code> и раздел документации «<a href="#build">Сборка приложения для Production</a>».</li>
            <li>В конструктор клиентской фабрики главного модуля добавляется вызов <code>initActivityMappers(this);</code>.</li>
            <li>Пакет <code>client.ui.module</code> переименован в <code>client.ui.plain</code>.</li>
            <li>Класс <code>JepClientSecurityModule</code> переименован в <code>UiSecurity</code>.</li>
            <li>Для создания презентера главного модуля в клиентской фабрике главного модуля используется метод <code>createMainModulePresenter()</code>.</li>
            <li>Для создания презентера модуля в клиентской фабрике модуля используется метод <code>createPlainModulePresenter(Place place)</code>.</li>
        </ul> </li>
</ul>
<br>
<!-- Put @see and @since tags down here. --></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
